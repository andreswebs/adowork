{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Go Project and Setup Dependencies",
        "description": "Create the Go project structure following 2025 Go community standards and install required dependencies including urfave/cli v3 for command-line argument parsing",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize a new Go module with 'go mod init azure-devops-cli'. Install urfave/cli v3 dependency with 'go get github.com/urfave/cli/v3' and use 'go mod tidy' for cleanup. Create simple directory structure with src/ folder containing all Go files. Implement main.go under src/ directory with urfave/cli v3 integration. The project uses a flat src/ structure for all code with src/main.go as the application entrypoint. Add version pinning in go.mod and include build/test commands following Go best practices.\n<info added on 2025-07-29T15:39:17.314Z>\nBinary Output Directory Update: The project now outputs built binaries to the bin/ directory as bin/adowork instead of the project root, following modern Go project standards for binary output organization. All build, run, and clean commands have been updated to use the bin/ directory structure. Documentation has been revised to reflect this change, providing better separation between source code and build artifacts while aligning with Go community conventions for project layout.\n</info added on 2025-07-29T15:39:17.314Z>",
        "testStrategy": "Verify project compiles successfully with 'go build ./src'. Test that urfave/cli v3 dependency is properly imported and basic CLI structure works. Validate directory structure follows the simple src/ layout. Test build and execution commands work correctly with src/main.go as entrypoint.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Go Module with Modern Standards",
            "description": "Create the foundational Go project structure using go mod init and establish proper module configuration following 2025 best practices",
            "status": "done",
            "dependencies": [],
            "details": "Run 'go mod init azure-devops-cli' to initialize the Go module. Create go.mod with proper version pinning and module configuration. Use 'go mod tidy' to clean up dependencies. Set up module with appropriate Go version requirement (go 1.21 or later) and prepare for dependency management.\n<info added on 2025-07-29T14:55:52.384Z>\nImplementation Plan for 'Initialize Go Module with Modern Standards':\n\n1. Create the foundational Go project structure using `go mod init`.\n2. Choose a modern, descriptive module path (e.g., github.com/your-org/azure-devops-cli).\n3. Ensure the project root is clean and follows 2025 Go best practices (no legacy files, use README.md, .gitignore, etc.).\n4. Set up initial Go module configuration (go.mod) and verify Go version is set to 1.22+.\n5. Prepare for dependency management and future subdirectories (cmd/, internal/, pkg/).\n\nNext steps:\n- Run `go mod init github.com/your-org/azure-devops-cli` in the project root.\n- Add a README.md and .gitignore if not present.\n- Confirm go.mod is created and Go version is correct.\n- Plan for urfave/cli v3 installation in the next subtask.\n\nThis plan will be refined as implementation proceeds.\n</info added on 2025-07-29T14:55:52.384Z>",
            "testStrategy": "Verify that go.mod file is created with proper Go version and 'go mod tidy' runs without errors. Check module name is correctly set."
          },
          {
            "id": 2,
            "title": "Install urfave/cli v3 with Version Pinning",
            "description": "Add the urfave/cli v3 library as a project dependency with proper version management and cleanup",
            "status": "done",
            "dependencies": [],
            "details": "Execute 'go get github.com/urfave/cli/v3' to install the latest urfave/cli v3 dependency. Run 'go mod tidy' to clean up and organize dependencies. Verify the dependency is properly added to go.mod and go.sum files with appropriate version pinning. Ensure compatibility with Go module standards.",
            "testStrategy": "Check that urfave/cli v3 appears in go.mod with correct version, go.sum is properly updated, and 'go mod download' completes successfully"
          },
          {
            "id": 3,
            "title": "Create Standard Directory Structure",
            "description": "Establish Go project directory structure with src/ folder",
            "status": "done",
            "dependencies": [],
            "details": "Create standard the Go project layout: src/ directory.",
            "testStrategy": "Verify all required directories are created."
          },
          {
            "id": 4,
            "title": "Implement main.go with urfave/cli v3 Integration",
            "description": "Create main.go file in src/ directory with proper urfave/cli v3 integration and modern Go practices",
            "status": "done",
            "dependencies": [],
            "details": "Create main.go in src/ directory with package main declaration. Import github.com/urfave/cli/v3 package. Set up CLI application structure with proper configuration. Include app metadata (name, usage, version) and basic command structure. Implement proper error handling and exit codes following CLI best practices.",
            "testStrategy": "Verify the application compiles with 'go build ./src' and runs with proper help output. Test CLI framework integration works correctly."
          },
          {
            "id": 5,
            "title": "Add Build Commands and Project Configuration",
            "description": "Set up build commands, testing configuration, and project tooling following Go community standards for flat src/ structure",
            "status": "done",
            "dependencies": [],
            "details": "Create Makefile or build scripts for common operations (build, test, clean) targeting the src/ directory. Configure proper build targets for the src/main.go application. Set up testing framework and ensure 'go test ./src' works correctly. Add any necessary project configuration files and documentation for build process. All build commands should target the flat src/ structure with src/main.go as the entrypoint.\n<info added on 2025-07-29T15:33:01.259Z>\nImplementation Plan for 'Add Build Commands and Project Configuration':\n\n1. Create a Makefile in the project root with standard Go targets:\n   - build: builds the app from src/main.go\n   - test: runs all tests in src/\n   - clean: removes build artifacts\n   - run: runs the app from src/main.go\n2. Ensure all commands work from the project root and use the flat src/ structure.\n3. Add documentation for the build process to the README.md.\n4. Confirm 'go build ./src' and 'go test ./src' work as expected.\n5. (Optional) Add .PHONY targets and comments for clarity.\n\nNext steps:\n- Implement the Makefile with the above targets.\n- Test each command to ensure correct operation.\n- Update README.md with build/test/run instructions.\n- Verify that the project can be built and run from the root using the Makefile.\n\nThis plan will be refined as implementation proceeds.\n</info added on 2025-07-29T15:33:01.259Z>\n<info added on 2025-07-29T15:38:40.632Z>\nBuild Output Location Update: The Makefile has been updated to output the built binary to the bin/ directory as bin/adowork, following modern Go project conventions. All build, run, and clean targets now use this new output location. The README documentation has been updated to reflect the new bin/ directory structure and build commands. This change aligns with Go community standards for binary output organization and provides better separation between source code and build artifacts.\n</info added on 2025-07-29T15:38:40.632Z>",
            "testStrategy": "Test build commands work correctly with 'go build ./src', 'go test ./src' passes, and project can be built and executed from different directories using src/main.go"
          },
          {
            "id": 6,
            "title": "Verify Complete Modern Go Project Setup",
            "description": "Perform comprehensive verification that all components integrate properly with the flat src/ structure",
            "status": "done",
            "dependencies": [],
            "details": "Test complete project setup with modern Go tooling using the flat src/ layout. Verify 'go build ./src' works correctly and produces executable from src/main.go. Test that 'go mod tidy' maintains clean dependencies. Ensure project structure follows the simple src/ directory standard. Validate CLI application runs with proper help and version output from src/main.go entrypoint. Check that all imports resolve correctly and compilation is clean.\n<info added on 2025-07-29T15:39:52.041Z>\nImplementation Plan for 'Verify Complete Modern Go Project Setup':\n\n1. Run `make build` and verify that `bin/adowork` is created and up to date.\n2. Run `make test` to ensure all tests in src/ pass (expecting no test files if none exist).\n3. Run `make run` to confirm the CLI app executes from the bin/ output and displays expected output.\n4. Run `go mod tidy` in src/ to ensure dependencies are clean and up to date.\n5. Run `go mod verify` in src/ to check module integrity.\n6. Run `go run src/main.go --help` and `bin/adowork --help` to verify help/version output.\n7. Confirm there are no compilation warnings or errors and that the flat src/ structure is respected.\n8. Review README.md and Makefile for accuracy and alignment with the bin/ output convention.\n\nNext steps:\n- Execute the above commands and document results.\n- Update subtask details with findings and any issues encountered.\n- Mark subtask as done if all checks pass.\n</info added on 2025-07-29T15:39:52.041Z>",
            "testStrategy": "Run comprehensive tests including 'go build ./src', 'go run ./src --help', 'go mod verify', and ensure zero compilation warnings or errors. Verify src/main.go serves as proper application entrypoint."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Environment Variable Validation",
        "description": "Create functionality to read and validate required environment variables (ADO_ORG, ADO_PROJECT, ADO_PAT) with proper error handling following Go best practices for 2025",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create a dedicated Config struct with struct tags for validation. Implement loadConfig() function that reads ADO_ORG, ADO_PROJECT, and ADO_PAT from environment variables using os.Getenv(). Perform validation at application startup before CLI flag processing. Add comprehensive validation to ensure all required variables are present and non-empty. Return grouped, user-friendly error messages if any required environment variable is missing. Consider using validation libraries with struct tags for enhanced validation capabilities.",
        "testStrategy": "Unit tests with different combinations of missing/present environment variables. Test error messages are clear, grouped, and user-friendly. Test integration with startup sequence before CLI processing. Test struct tag validation if implemented.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Configuration Structure with Validation Tags",
            "description": "Create a configuration struct with struct tags to support validation libraries and follow Go best practices for 2025",
            "status": "done",
            "dependencies": [],
            "details": "Define a Config struct with fields for ADO_ORG, ADO_PROJECT, and ADO_PAT as string types. Add struct tags for validation (e.g., `validate:\"required\"` or `env:\"ADO_ORG,required\"`). Include any additional fields that might be needed for Azure DevOps API connections. Create constants for the environment variable names to avoid hardcoding strings throughout the codebase. Consider using popular validation libraries like go-playground/validator or similar. This struct will serve as the foundation for all configuration-related operations.\n<info added on 2025-07-29T17:17:27.610Z>\nImplementation Plan for 'Define Configuration Structure with Validation Tags':\n\n1. Define a Config struct with fields for ADO_ORG, ADO_PROJECT, and ADO_PAT, all as string types.\n2. Add struct tags for validation, e.g., `validate:\"required\"` for each field.\n3. Create constants for the environment variable names to avoid hardcoding.\n4. Consider extensibility for future Azure DevOps config fields.\n5. Prepare for use with a validation library (e.g., go-playground/validator) but keep it compatible with standard Go validation if needed.\n\nNext steps:\n- Implement the Config struct and constants in main.go.\n- Add struct tags for validation.\n- Document the struct and tags for clarity.\n</info added on 2025-07-29T17:17:27.610Z>\n<info added on 2025-07-29T17:24:20.821Z>\nUpdated naming convention implemented: Environment variable names changed from ADO_* to ADO_* format. Config struct fields renamed to Organization, Project, and PAT for better clarity. Constants updated to EnvADOOrg, EnvADOProject, and EnvADOPAT following the new ADO_ prefix convention. All struct tags, validation references, and documentation updated to reflect the consistent ADO_ naming scheme throughout the codebase.\n</info added on 2025-07-29T17:24:20.821Z>",
            "testStrategy": "Unit tests to verify struct fields are properly defined with correct tags. Test struct initialization with sample values. Test validation tag functionality if using validation library."
          },
          {
            "id": 2,
            "title": "Implement Environment Variable Reading",
            "description": "Create functionality to read environment variables using os.Getenv() and populate the configuration struct",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement a function that uses os.Getenv() to read ADO_ORG, ADO_PROJECT, and ADO_PAT environment variables. Create a constructor or initialization function that populates the Config struct with these values. Handle the case where environment variables might not be set by storing empty strings initially. This function should focus solely on reading values without validation. Consider using environment variable mapping libraries if struct tags support them.\n<info added on 2025-07-29T17:19:24.565Z>\nImplementation Plan for 'Implement Environment Variable Reading':\n\n1. Implement a function `readConfigFromEnv()` that uses os.Getenv to read ADO_ORG, ADO_PROJECT, and ADO_PAT.\n2. Populate and return a Config struct with these values.\n3. Do not perform validation in this function—just reading.\n4. Prepare for future integration with validation logic.\n5. Add documentation for the function and its usage.\n\nNext steps:\n- Implement `readConfigFromEnv()` in main.go.\n- Test with different environment variable settings.\n</info added on 2025-07-29T17:19:24.565Z>",
            "testStrategy": "Unit tests with mocked environment variables using os.Setenv() and os.Unsetenv(). Test reading existing and non-existing environment variables."
          },
          {
            "id": 3,
            "title": "Implement Comprehensive Validation Logic",
            "description": "Create validation functions that provide grouped, user-friendly error messages following Go best practices",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Implement validation logic that checks each required field in the Config struct is non-empty. Create a validate() method or function that returns grouped error messages for better user experience. Use Go's error handling patterns to return descriptive, user-friendly error messages that group related issues together. Consider using validation libraries that work with struct tags for more sophisticated validation. The validation should be comprehensive and check all three required variables, providing actionable feedback to users.",
            "testStrategy": "Unit tests with various combinations of missing, empty, and valid environment variables. Verify that validation correctly identifies missing variables and provides grouped, user-friendly error messages."
          },
          {
            "id": 4,
            "title": "Create User-Friendly Grouped Error Messages",
            "description": "Implement error message generation that groups related issues and provides clear, actionable guidance to users",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Create error message generation that groups related validation failures and provides user-friendly, actionable guidance. Instead of individual error messages for each missing variable, create grouped messages that list all missing variables together with clear instructions on how to set them. Use fmt.Errorf() or custom error types to create informative error messages. Include examples of how to set environment variables in the error messages. Consider creating different error categories (missing vs empty vs invalid) and group them appropriately.",
            "testStrategy": "Unit tests to verify error messages are grouped, clear, and user-friendly. Test that error messages provide actionable guidance and examples. Verify different error categories are properly grouped."
          },
          {
            "id": 5,
            "title": "Implement loadConfig() Function with Startup Integration",
            "description": "Create the main loadConfig() function that integrates with application startup before CLI flag processing",
            "status": "done",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement the main loadConfig() function that combines environment variable reading, validation, and error handling. The function should return a populated Config struct and an error. Design the function to be called at application startup before CLI flag processing begins. Call the reading function to populate the struct, then call validation, and return appropriate grouped errors with user-friendly messages. This function serves as the main entry point for configuration loading and should handle all error cases gracefully while following Go best practices for 2025.",
            "testStrategy": "Integration tests that cover the complete flow from environment variable reading through validation. Test successful configuration loading and various failure scenarios with appropriate grouped error messages. Test integration with startup sequence timing."
          },
          {
            "id": 6,
            "title": "Integrate Validation with Application Startup Sequence",
            "description": "Ensure environment variable validation occurs at application startup before CLI flag processing",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Integrate the loadConfig() function into the application's main startup sequence, ensuring it runs before CLI flag parsing and processing. Modify the main function or application initialization to call loadConfig() early in the startup process. Handle configuration validation failures by exiting gracefully with appropriate error codes and user-friendly messages. Ensure that if environment validation fails, the application doesn't proceed to CLI processing, following Go best practices for early validation and fail-fast principles.",
            "testStrategy": "Integration tests to verify configuration validation occurs before CLI processing. Test that application exits gracefully with proper error codes when validation fails. Test successful startup flow when all environment variables are properly set."
          }
        ]
      },
      {
        "id": 3,
        "title": "Setup CLI Framework with urfave/cli",
        "description": "Configure the CLI application structure using urfave/cli v3 following v3-style command structure with cli.Command as the main entry point, required and optional flags, proper error handling, and environment validation integration",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create CLI command using cli.Command (not cli.App) as the main entry point with urfave/cli v3 best practices. Call cmd.Run(context.Background(), os.Args) in main(). Define required flags: --type (string, alias -t) and --title (string, alias -T) with Required:true for validation. Define optional flags: --description (string, alias -d), --parent (int, alias -p), and --dry-run (bool). Configure comprehensive command metadata (name, usage, version, authors). Use cli.Exit for error handling with proper exit codes. Integrate environment validation before command execution using Action function signature func(context.Context, *cli.Command) error.",
        "testStrategy": "Test CLI parsing with various flag combinations using urfave/cli v3 command patterns. Verify required flags cause proper cli.Exit errors when missing. Test that optional flags work correctly when provided or omitted. Validate error handling produces correct exit codes and clear messages. Test environment validation integration with cmd.Run() execution flow.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize CLI Command Structure with urfave/cli v3 Best Practices",
            "description": "Create the basic CLI command structure using cli.Command as the main entry point with urfave/cli v3 framework following v3-style command patterns",
            "status": "done",
            "dependencies": [],
            "details": "Import github.com/urfave/cli/v3 package. Create a new CLI command using cli.Command (not cli.App) in main.go following v3 best practices. Set up the main() function to call cmd.Run(context.Background(), os.Args). Create a placeholder Action function with signature func(context.Context, *cli.Command) error that will be implemented in later subtasks. Follow urfave/cli v3 patterns for proper command initialization and error handling setup.\n<info added on 2025-07-29T17:44:40.158Z>\nImplementation plan for this subtask:\n- Import github.com/urfave/cli/v3 if not already present.\n- Ensure main.go uses cli.Command (not cli.App) as the main entry point, matching urfave/cli v3 best practices.\n- In main(), create a cli.Command instance and set up the main application entry point.\n- Call cmd.Run(context.Background(), os.Args) in main().\n- Add a placeholder Action function with signature func(context.Context, *cli.Command) error.\n- Confirm that the CLI command initializes without errors and responds to --help.\n- Do not add flags or metadata yet; those are for later subtasks.\n- This will establish the correct v3-style CLI skeleton for further development.\n</info added on 2025-07-29T17:44:40.158Z>",
            "testStrategy": "Test that the CLI command initializes without errors using urfave/cli v3 patterns and can be invoked with --help flag"
          },
          {
            "id": 2,
            "title": "Configure Comprehensive Command Metadata",
            "description": "Set up the CLI command metadata including name, usage description, version information, and authors directly on the cli.Command following urfave/cli v3 best practices",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Configure cmd.Name to 'azure-devops-cli'. Set cmd.Usage to describe the tool's purpose for creating Azure DevOps work items. Set cmd.Version to '1.0.0'. Add cmd.Description with detailed information about the tool's functionality and usage examples. Configure cmd.Authors with proper author information following urfave/cli v3 metadata standards. Add comprehensive metadata coverage using v3-supported fields on cli.Command.",
            "testStrategy": "Verify all metadata appears correctly when running with --help and --version flags, including authors and description information"
          },
          {
            "id": 3,
            "title": "Define Required CLI Flags with Required:true Validation",
            "description": "Implement the required command-line flags --type and --title using urfave/cli v3 Required:true validation in the Flags field of cli.Command",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create cli.Flag slice in the cmd.Flags field using urfave/cli v3 patterns. Add cli.StringFlag for --type with Name: 'type', Usage: 'Work item type (e.g., Task, Bug, User Story)', Required: true, Aliases: []string{'t'} for convenience. Add cli.StringFlag for --title with Name: 'title', Usage: 'Work item title', Required: true, Aliases: []string{'T'}. Ensure proper validation messages are configured for v3 command structure.",
            "testStrategy": "Test that CLI shows proper urfave/cli v3 error messages when required flags are missing and accepts valid values when provided"
          },
          {
            "id": 4,
            "title": "Define Optional CLI Flags with Clear Descriptions",
            "description": "Implement the optional command-line flags --description, --parent, and --dry-run with comprehensive descriptions in the cli.Command Flags field",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Add cli.StringFlag for --description with Name: 'description', Usage: 'Work item description (supports markdown)', Required: false, Aliases: []string{'d'}. Add cli.IntFlag for --parent with Name: 'parent', Usage: 'Parent work item ID for hierarchical relationships', Required: false, Aliases: []string{'p'}. Add cli.BoolFlag for --dry-run with Name: 'dry-run', Usage: 'Show what would be created without making changes', Required: false. Append these to the existing cmd.Flags slice with clear, descriptive usage text.",
            "testStrategy": "Test that optional flags work correctly when provided and have appropriate default values when omitted. Verify aliases work properly."
          },
          {
            "id": 5,
            "title": "Implement Flag Extraction and cli.Exit Error Handling",
            "description": "Set up proper flag extraction using cmd.String(), cmd.Int(), cmd.Bool() methods and implement cli.Exit error handling with correct exit codes",
            "status": "done",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement the Action function with signature func(context.Context, *cli.Command) error. Extract flag values using cmd.String('type'), cmd.String('title'), cmd.String('description'), cmd.Int('parent'), and cmd.Bool('dry-run'). Use cli.Exit for all user error conditions with proper exit codes (1 for general errors, 2 for usage errors). Create helper functions for safe flag extraction if needed. Add comprehensive error messages that guide users to correct usage. Follow Go CLI standards for error handling and exit codes.",
            "testStrategy": "Test error handling produces correct exit codes using cli.Exit. Verify flag extraction works correctly for all flag types. Test that error messages are clear and actionable."
          },
          {
            "id": 6,
            "title": "Integrate Environment Validation and Add Usage Examples",
            "description": "Integrate environment validation from Task 2 before command execution and enhance help text with usage examples following urfave/cli v3 best practices",
            "status": "done",
            "dependencies": [
              2,
              5
            ],
            "details": "In the Action function, call loadConfig() from Task 2 to validate environment variables before main logic execution. If environment validation fails, return cli.Exit with clear error message and non-zero exit code. Add comprehensive usage examples in cmd.Description or cmd.Usage fields. Include examples for both basic and advanced usage patterns. Optionally implement custom OnUsageError handler for better usage error messages. Follow urfave/cli v3 documentation standards for help text formatting.",
            "testStrategy": "Test that environment validation runs before command execution and produces proper cli.Exit errors when environment variables are missing. Verify help output is comprehensive and user-friendly with usage examples. Test integration between environment validation and CLI command flow."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Debug Logging System",
        "description": "Create a debug logging system that outputs to stderr when DEBUG environment variable is set",
        "status": "cancelled",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "Create a DebugLogger struct that checks for DEBUG environment variable once at startup using os.Getenv(\"DEBUG\"). Implement debug logging functions that write to stderr using log.New(os.Stderr, \"DEBUG: \", log.LstdFlags|log.Lshortfile). Only output debug messages when DEBUG is set. Include logging for environment variable loading, API client setup, work item creation, and error handling following Go debug logging best practices as of 2025.",
        "testStrategy": "Test logging behavior with DEBUG set and unset. Verify debug messages go to stderr and not stdout. Test that production usage (DEBUG unset) produces no debug output. Verify log.Lshortfile provides proper file context.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Debug Logger Structure",
            "description": "Implement the core debug logger structure that checks for DEBUG environment variable once at startup and manages debug state",
            "status": "cancelled",
            "dependencies": [],
            "details": "Create a DebugLogger struct with fields for enabled state and logger instance. Implement NewDebugLogger() constructor that checks os.Getenv(\"DEBUG\") once at startup and initializes log.New(os.Stderr, \"DEBUG: \", log.LstdFlags|log.Lshortfile) if DEBUG is set. Store enabled state as boolean field to avoid repeated environment variable checks. Use log.Lshortfile flag for file context following Go best practices.",
            "testStrategy": "Test logger creation with DEBUG set and unset. Verify enabled state is correctly determined. Verify log.Lshortfile provides proper file context in output."
          },
          {
            "id": 2,
            "title": "Implement Conditional Debug Logging Methods",
            "description": "Add conditional debug logging methods to the logger structure that only output when DEBUG is enabled",
            "status": "cancelled",
            "dependencies": [
              1
            ],
            "details": "Implement Debug(), Debugf(), and Debugln() methods on DebugLogger struct. Each method should check the enabled state before writing to stderr to avoid performance overhead when debugging is disabled. Use the internal logger instance for actual output. Methods should accept variadic arguments and format strings appropriately. Ensure methods are no-op when DEBUG is not set.",
            "testStrategy": "Test that methods only output when DEBUG is enabled. Verify output format includes DEBUG prefix, timestamps, and file context. Test performance impact when DEBUG is disabled."
          },
          {
            "id": 3,
            "title": "Add Environment Variable Loading Debug Logging",
            "description": "Integrate debug logging into environment variable loading operations from task 2",
            "status": "cancelled",
            "dependencies": [
              2
            ],
            "details": "Add debug logging calls to the loadConfig() function from task 2. Log when each environment variable (ADO_ORG, ADO_PROJECT, ADO_PAT) is being read. Log success/failure for each variable load. Mask sensitive PAT values in debug output by showing only first 4 characters followed by asterisks. Include validation results and any error conditions.",
            "testStrategy": "Test debug output during config loading. Verify PAT values are properly masked in debug logs. Test logging of validation failures and success cases."
          },
          {
            "id": 4,
            "title": "Add API Client Setup Debug Logging",
            "description": "Integrate debug logging into API client initialization and setup operations",
            "status": "cancelled",
            "dependencies": [
              2
            ],
            "details": "Add debug logging to API client setup including HTTP client configuration, base URL construction, and authentication header preparation. Log client initialization parameters (excluding sensitive PAT data). Log when API client is ready for use. Include debug logging for any client configuration errors or warnings.",
            "testStrategy": "Test debug output during API client setup. Verify sensitive authentication data is properly handled. Test logging of client configuration issues."
          },
          {
            "id": 5,
            "title": "Add Work Item Creation Debug Logging",
            "description": "Integrate debug logging into work item creation operations and API calls",
            "status": "cancelled",
            "dependencies": [
              2
            ],
            "details": "Add debug logging to work item creation functions including payload construction, HTTP request details (method, URL, headers - excluding Authorization), and response handling. Log API call timing information and response status codes. Log work item creation success with ID and URL. Ensure sensitive data like PAT tokens are not logged in full.",
            "testStrategy": "Test debug output during work item creation. Verify sensitive data is properly handled. Test with both successful and failed API calls. Verify timing information is logged."
          },
          {
            "id": 6,
            "title": "Add Error Handling Debug Logging",
            "description": "Integrate debug logging into error handling paths throughout the application",
            "status": "cancelled",
            "dependencies": [
              2
            ],
            "details": "Add debug logging to error handling code paths including API failures, validation errors, and configuration issues. Log error context, stack traces where appropriate, and recovery attempts. Include debug logging for error propagation and handling decisions. Ensure error logs provide sufficient context for debugging.",
            "testStrategy": "Test debug output during various error conditions. Verify error context is properly logged. Test that debug logs aid in troubleshooting common issues."
          },
          {
            "id": 7,
            "title": "Create Global Debug Logger Instance",
            "description": "Create a global debug logger instance and integrate it throughout the application",
            "status": "cancelled",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create a global debugLogger variable initialized in main() or init() function using NewDebugLogger(). Export debug logging functions (Debug, Debugf, Debugln) that use the global instance. Ensure the global logger is available to all parts of the application. Add debug logging for application startup, shutdown, and key decision points following Go best practices for global state management.",
            "testStrategy": "Test global logger accessibility from different parts of the application. Verify consistent debug output behavior across all modules. Test application lifecycle debug logging."
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Azure DevOps REST API Client Structure",
        "description": "Implement the basic structure for Azure DevOps REST API client with authentication using Personal Access Token, secure PAT handling, and structured error handling",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "Create an AzureDevOpsClient struct containing organization, project, and PAT with secure handling. Implement authentication using Basic Auth with empty username and PAT as password (base64 encoded). Set up HTTP client with proper headers, timeouts, and connection pooling. Create structured error handling with APIError type. Implement buildURL and makeRequest helpers for endpoint construction and authenticated requests. Follow Azure DevOps API and Go HTTP client best practices as of 2025.",
        "testStrategy": "Unit tests for client initialization and authentication header generation. Test URL construction for different organizations and projects. Mock HTTP client tests for authentication flow. Test error handling with APIError type. Test HTTP client configuration including timeouts and connection pooling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AzureDevOpsClient struct and constructor",
            "description": "Define the main AzureDevOpsClient struct with fields for organization, project, and Personal Access Token, and implement a constructor function",
            "status": "done",
            "dependencies": [],
            "details": "Create a struct with fields: Organization (string), Project (string), PAT (string), and HTTPClient (*http.Client). Implement NewAzureDevOpsClient(org, project, pat string) function that initializes the struct with provided values and creates a new HTTP client with appropriate timeout settings. Include validation to ensure none of the required fields are empty.",
            "testStrategy": "Unit tests for constructor with valid and invalid inputs. Test that struct fields are properly initialized and HTTP client is created."
          },
          {
            "id": 2,
            "title": "Implement Basic Authentication encoding with secure PAT handling",
            "description": "Create authentication functionality that securely encodes the PAT using Basic Auth format with empty username",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement encodeBasicAuth() method that takes the PAT and creates Basic Auth credentials using empty username and PAT as password. Use base64.StdEncoding.EncodeToString() to encode the ':PAT' string. Implement secure PAT handling by avoiding PAT storage in logs and ensuring proper memory handling. Store the encoded value for reuse in HTTP requests. The format should be 'Basic ' + base64(':' + pat).",
            "testStrategy": "Unit tests to verify correct base64 encoding of PAT. Test with different PAT values and verify the output matches expected Basic Auth format. Test that PAT is not exposed in logs or error messages."
          },
          {
            "id": 3,
            "title": "Configure HTTP client with timeouts and connection pooling",
            "description": "Set up the HTTP client with proper timeouts, connection pooling, and default headers including Authorization and Content-Type",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create configureHTTPClient() method that sets up HTTP client with appropriate timeouts (connect, request, idle). Configure connection pooling with MaxIdleConns and MaxIdleConnsPerHost for optimal performance. Set default headers: 'Authorization' header to 'Basic <encoded_pat>' and 'Content-Type' header to 'application/json-patch+json' for Azure DevOps API compatibility. Follow Go HTTP client best practices as of 2025.\n<info added on 2025-07-29T19:28:14.597Z>\nImplementation completed successfully. The configureHTTPClient method creates an http.Client with 30-second timeout and connection pooling (MaxIdleConns, MaxIdleConnsPerHost). Added RoundTripperWithHeaders custom transport to automatically inject Authorization and Content-Type headers into all requests. SetDefaultHeaders method configures the client to use these headers. NewADOClient constructor updated to call configureHTTPClient during initialization. All implementation follows Go HTTP client best practices for 2025. Next step: ensure SetDefaultHeaders is called after client creation for all requests.\n</info added on 2025-07-29T19:28:14.597Z>",
            "testStrategy": "Test that HTTP client is configured with proper timeouts and connection pooling settings. Verify headers are correctly set on HTTP requests. Test connection reuse and pooling behavior."
          },
          {
            "id": 4,
            "title": "Implement buildURL helper for Azure DevOps endpoints",
            "description": "Create buildURL helper function to construct proper Azure DevOps REST API URLs based on organization and project",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement buildURL(endpoint string) method that constructs URLs using format 'https://dev.azure.com/{organization}/{project}/_apis/{endpoint}'. Include URL validation and proper encoding of organization and project names to handle special characters. Create specific helper methods like buildWorkItemURL(id int) and buildWorkItemsURL() that use the base buildURL function.\n<info added on 2025-07-29T19:41:13.399Z>\nImplementation completed successfully. All three URL helper methods (buildURL, buildWorkItemURL, buildWorkItemsURL) have been implemented in the ADOClient following Azure DevOps REST API standards and Go best practices. The buildURL method properly handles URL encoding for organization and project names, while the specific helper methods provide convenient access to work item endpoints. Implementation follows the specified URL format and includes proper error handling.\n</info added on 2025-07-29T19:41:13.399Z>",
            "testStrategy": "Unit tests for URL construction with various organization and project names. Test special characters and spaces are properly encoded. Verify different endpoint URLs are constructed correctly."
          },
          {
            "id": 5,
            "title": "Create APIError type for structured error handling",
            "description": "Implement APIError type to provide structured error handling for Azure DevOps API responses",
            "status": "done",
            "dependencies": [],
            "details": "Create APIError struct with fields: StatusCode (int), Message (string), Details (string), and RequestID (string). Implement Error() method to satisfy error interface. Add helper functions like NewAPIError() and IsAPIError() for error creation and type checking. Include methods to extract error details from Azure DevOps API error responses with proper JSON parsing.\n<info added on 2025-07-29T19:32:50.205Z>\nImplementation completed successfully. APIError type fully implemented with all required components:\n\n- APIError struct created with StatusCode, Message, Details, and RequestID fields\n- Error() method implemented to satisfy Go's error interface\n- NewAPIError() constructor function for creating errors from HTTP status codes and response bodies\n- IsAPIError() type assertion helper for error type checking\n- parseAPIErrorBody() internal helper function to extract structured error information from Azure DevOps API JSON error responses, including support for nested error structures\n- Full JSON parsing integration for processing API error responses\n\nAll functionality tested and verified. No implementation issues encountered. Ready for integration with HTTP request handling in subsequent subtasks.\n</info added on 2025-07-29T19:32:50.205Z>",
            "testStrategy": "Unit tests for APIError creation and error interface implementation. Test error parsing from various Azure DevOps API error response formats. Verify error messages are properly formatted and informative."
          },
          {
            "id": 6,
            "title": "Create makeRequest helper for authenticated HTTP requests",
            "description": "Implement makeRequest helper method for making authenticated HTTP requests to Azure DevOps API endpoints with structured error handling",
            "status": "done",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Create makeRequest(method, endpoint string, body io.Reader) (*http.Response, error) method that uses buildURL for endpoint construction and applies authentication headers. Implement GET, POST, PATCH convenience wrappers. Include comprehensive error handling using APIError type for HTTP status codes and response parsing. Add request logging integration with the debug logging system from task 4. Handle common Azure DevOps API error responses and rate limiting.\n<info added on 2025-07-29T19:43:17.909Z>\nImplementation completed successfully. The makeRequest helper method has been implemented with full authentication support, structured error handling using APIError type, and convenience wrappers for GET, POST, and PATCH operations. The implementation includes proper URL construction, default header management, and lint error resolution. The method is now ready for integration with Azure DevOps API endpoints and can be used by other components requiring authenticated HTTP requests.\n</info added on 2025-07-29T19:43:17.909Z>",
            "testStrategy": "Unit tests with mock HTTP client to verify requests are properly formed using buildURL and authentication headers. Test error handling returns proper APIError types for various HTTP status codes. Integration tests with actual Azure DevOps API endpoints using test PAT."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Work Item Creation API Call",
        "description": "This task has been made obsolete by the refactoring in Task 11, which implemented work item creation using the official azure-devops-go-api library. The core functionality is now covered by the new ADOClient implementation.",
        "status": "cancelled",
        "dependencies": [
          5
        ],
        "priority": "high",
        "details": "Originally intended to implement createWorkItem() function with manual JSON-Patch payload construction for Azure DevOps REST API. However, Task 11 has superseded this approach by implementing a more robust solution using the official azure-devops-go-api library. The ADOClient implementation in Task 11 provides the same work item creation functionality with better error handling, type safety, and maintainability. This task is now considered fulfilled through the alternative implementation.",
        "testStrategy": "Testing requirements have been transferred to Task 11's ADOClient implementation. The official library provides better testing capabilities and more reliable API interactions than the manual REST implementation originally planned.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JSON-Patch Payload Construction",
            "description": "Create the core payload building functionality for Azure DevOps work item creation using JSON-Patch format",
            "status": "cancelled",
            "dependencies": [],
            "details": "Implement buildWorkItemPayload() function that constructs JSON-Patch operations array. Create operation objects with 'op': 'add', 'path': '/fields/System.Title', 'value': title for required title field. Add conditional operations for System.Description and System.Parent when provided. Return properly formatted JSON-Patch payload as []map[string]interface{} or similar structure. Include validation to ensure title is not empty.",
            "testStrategy": "Unit tests for payload construction with various input combinations (title only, title+description, title+parent, all fields). Verify JSON structure matches Azure DevOps JSON-Patch requirements."
          },
          {
            "id": 2,
            "title": "Implement HTTP Client and Request Setup",
            "description": "Set up HTTP client configuration and request building for Azure DevOps API calls",
            "status": "cancelled",
            "dependencies": [
              1
            ],
            "details": "Create HTTP client with appropriate timeout settings. Implement buildAPIRequest() function that constructs PATCH request to Azure DevOps endpoint using format '{organization}/{project}/_apis/wit/workitems/${type}?api-version=7.1'. Set required headers including 'Content-Type: application/json-patch+json' and 'Authorization: Basic {base64-encoded-PAT}'. Encode PAT using base64 encoding with format ':PAT'. Include proper URL construction and validation.",
            "testStrategy": "Unit tests for request building with different organizations, projects, and work item types. Test header construction and PAT encoding. Verify URL format correctness."
          },
          {
            "id": 3,
            "title": "Implement API Call Execution",
            "description": "Execute the HTTP request to Azure DevOps API and handle the raw response",
            "status": "cancelled",
            "dependencies": [
              2
            ],
            "details": "Implement executeAPICall() function that sends the constructed HTTP request using http.Client.Do(). Handle HTTP response status codes appropriately - success (200-299), client errors (400-499), and server errors (500-599). Read response body using io.ReadAll(). Return raw response data and any HTTP-level errors. Include proper resource cleanup with defer response.Body.Close().",
            "testStrategy": "Integration tests with test Azure DevOps instance. Test various HTTP status code scenarios. Mock HTTP client for unit testing different response conditions."
          },
          {
            "id": 4,
            "title": "Implement Response Parsing and Data Extraction",
            "description": "Parse Azure DevOps API response and extract work item ID and URL information",
            "status": "cancelled",
            "dependencies": [
              3
            ],
            "details": "Implement parseWorkItemResponse() function that unmarshals JSON response into appropriate struct. Extract work item ID from response.id field and work item URL from response.url field. Handle JSON parsing errors gracefully. Create WorkItemResult struct to hold extracted data including ID, URL, and any other relevant fields. Validate that required fields are present in response.",
            "testStrategy": "Unit tests with various Azure DevOps API response formats. Test JSON parsing with malformed responses. Verify correct extraction of ID and URL fields."
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Main Function Integration",
            "description": "Add comprehensive error handling and integrate all components into the main createWorkItem() function",
            "status": "cancelled",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement createWorkItem() function that orchestrates all components: payload construction, request building, API execution, and response parsing. Add comprehensive error handling for each step with descriptive error messages. Handle specific Azure DevOps API errors (authentication failures, project not found, invalid work item type, etc.). Return structured error information that can be used by calling code. Include input validation for required parameters (organization, project, PAT, work item type, title).",
            "testStrategy": "Integration tests covering end-to-end work item creation flow. Test error scenarios including invalid credentials, missing projects, network failures. Unit tests for error message formatting and input validation."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement PAT Owner Assignment Logic",
        "description": "Add functionality to automatically assign created work items to the PAT owner by default using the azure-devops-go-api library",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "details": "Implement functionality to retrieve the PAT owner's identity and add the System.AssignedTo field to the JSON patch document for work item creation. Since the azure-devops-go-api library may not have a direct method to get the current user, this may require a separate API call to the connectionData endpoint or manual field addition. The assignment should be added to the JSON patch operations array that gets sent to Azure DevOps.",
        "testStrategy": "Test PAT owner lookup and assignment with valid and invalid PATs. Verify work items are correctly assigned to PAT owner using the JSON patch format. Test graceful handling when user lookup fails.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research azure-devops-go-api library for user identity retrieval",
            "description": "Investigate available methods in the azure-devops-go-api library to retrieve the current authenticated user's identity",
            "status": "done",
            "dependencies": [],
            "details": "Examine the azure-devops-go-api library documentation and source code to find methods for retrieving the current user's identity. Check if there are direct methods on the client or if we need to use specific service clients. If no direct method exists, identify the appropriate endpoint (like connectionData) that can be called through the library's HTTP client or core services.",
            "testStrategy": "Review library documentation and test available methods. Verify which approach provides the necessary user identity information."
          },
          {
            "id": 2,
            "title": "Implement user identity retrieval using azure-devops-go-api",
            "description": "Create function to get PAT owner identity using the most appropriate method from the azure-devops-go-api library",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Based on the research from the previous subtask, implement a function to retrieve the authenticated user's identity. This may involve using a specific service client from the library or making a call to the connectionData endpoint. Create a function that returns the user's unique identifier that can be used for work item assignment. Handle authentication and API errors appropriately.",
            "testStrategy": "Test user identity retrieval with valid PATs. Test error handling with invalid or expired PATs. Verify the returned user information contains necessary fields for assignment."
          },
          {
            "id": 3,
            "title": "Add System.AssignedTo field to JSON patch document",
            "description": "Modify the work item creation logic to include System.AssignedTo field in the JSON patch operations",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Update the JSON patch document creation to include a patch operation for the System.AssignedTo field when user identity is successfully retrieved. The patch operation should follow the format: {'op': 'add', 'path': '/fields/System.AssignedTo', 'value': userIdentity}. Ensure this operation is added to the existing patch operations array used by the azure-devops-go-api library for work item creation.",
            "testStrategy": "Test that the JSON patch document includes the assignment operation when user lookup succeeds. Verify the patch operation format is correct for Azure DevOps API. Test work item creation with the assignment field."
          },
          {
            "id": 4,
            "title": "Implement graceful error handling for assignment failures",
            "description": "Add error handling to ensure work item creation continues even when user assignment fails",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement error handling logic that allows work item creation to proceed normally when user identity retrieval fails. Log appropriate debug information about assignment failures while ensuring the main work item creation flow is not interrupted. The System.AssignedTo field should only be added to the patch document when user lookup is successful.",
            "testStrategy": "Test that work item creation succeeds even when user lookup fails. Verify that failed assignment attempts don't break the main workflow. Test appropriate error logging for troubleshooting."
          },
          {
            "id": 5,
            "title": "Integrate assignment logic with existing work item creation flow",
            "description": "Integrate the PAT owner assignment functionality into the existing work item creation process",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Modify the existing work item creation function to call the user identity retrieval and conditionally add the assignment field to the patch document. Ensure the integration works seamlessly with the azure-devops-go-api library's work item creation methods. The assignment should be attempted before each work item creation but should not delay or complicate the creation process.",
            "testStrategy": "Test end-to-end work item creation with assignment enabled. Verify integration doesn't affect existing functionality. Test that assignment works correctly with different work item types."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Dry-Run Mode",
        "description": "Add --dry-run flag support to preview the API payload without making actual API calls using the azure-devops-go-api library",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "details": "Modify createWorkItem() function to accept dry-run parameter. When --dry-run flag is set, construct the []webapi.JsonPatchOperation document that would be passed to the CreateWorkItem function and print it to stdout instead of making actual API call. Format JSON output for readability using json.MarshalIndent(). Exit successfully after printing the patch operations without making HTTP request.",
        "testStrategy": "Test dry-run mode produces correct JsonPatchOperation array. Verify no API calls are made in dry-run mode. Test that patch operations match what would be sent to azure-devops-go-api CreateWorkItem function.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add dry-run flag to command line interface",
            "description": "Implement command line flag parsing to accept --dry-run option that enables preview mode without making actual API calls",
            "status": "done",
            "dependencies": [],
            "details": "Add --dry-run flag using flag package or similar CLI library. Set up boolean variable to track dry-run state. Ensure flag is properly documented in help text. Parse command line arguments and store dry-run state in accessible variable for other functions.",
            "testStrategy": "Test flag parsing with and without --dry-run flag. Verify help text includes dry-run option description."
          },
          {
            "id": 2,
            "title": "Modify createWorkItem function signature",
            "description": "Update the createWorkItem() function to accept a dry-run parameter and pass it through the function call chain",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Add boolean dryRun parameter to createWorkItem() function signature. Update all calls to createWorkItem() to pass the dry-run flag value. Ensure the parameter is properly propagated through any intermediate function calls that lead to API execution.",
            "testStrategy": "Test function calls with both true and false dry-run values. Verify parameter is correctly passed through call chain."
          },
          {
            "id": 3,
            "title": "Implement JsonPatchOperation construction logic",
            "description": "Create the complete []webapi.JsonPatchOperation array that would be passed to the azure-devops-go-api CreateWorkItem function",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Build the complete JsonPatchOperation array structure that would be sent to Azure DevOps API via the azure-devops-go-api library. Include all required patch operations for work item type, title, description, and any other configured fields. Ensure patch operations structure matches exactly what would be passed to the CreateWorkItem function. Use same data sources and validation as normal execution path.",
            "testStrategy": "Compare constructed patch operations with actual CreateWorkItem function input. Verify all required operations are present and correctly formatted as JsonPatchOperation objects."
          },
          {
            "id": 4,
            "title": "Add JSON formatting and output functionality",
            "description": "Implement pretty-printing of JsonPatchOperation array using json.MarshalIndent for readable output to stdout",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Use json.MarshalIndent() with appropriate indentation (2 or 4 spaces) to format JsonPatchOperation array for human readability. Output formatted JSON to stdout using fmt.Print() or similar. Handle any JSON marshaling errors gracefully with appropriate error messages.",
            "testStrategy": "Test JSON output formatting with various patch operation structures. Verify output is valid JSON and properly indented."
          },
          {
            "id": 5,
            "title": "Implement dry-run execution path and early exit",
            "description": "Add conditional logic to skip API call execution when in dry-run mode and exit successfully after displaying patch operations",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Add conditional check for dry-run mode before calling azure-devops-go-api CreateWorkItem function. When dry-run is enabled, output the formatted JsonPatchOperation array and exit with success status (exit code 0) without making any network calls. Ensure no API authentication or HTTP requests occur in dry-run mode. Maintain normal execution path when dry-run is disabled.",
            "testStrategy": "Verify no network calls are made in dry-run mode. Test successful exit after patch operations display. Confirm normal API execution when dry-run is disabled."
          },
          {
            "id": 6,
            "title": "Add dry-run flag to CLI arguments",
            "description": "Add --dry-run command line flag using flag package and store in global variable for access throughout application",
            "status": "done",
            "dependencies": [],
            "details": "Import flag package and add dryRun boolean flag using flag.Bool(). Parse flags in main() function. Store dry-run state in accessible variable for other functions to check.",
            "testStrategy": "Test flag parsing with and without --dry-run flag. Verify flag value is correctly set and accessible."
          },
          {
            "id": 7,
            "title": "Modify createWorkItem function signature",
            "description": "Update createWorkItem() function to accept dry-run parameter and conditionally execute API calls",
            "status": "done",
            "dependencies": [],
            "details": "Add dryRun bool parameter to createWorkItem() function signature. Update all function calls to pass the dry-run flag value. Modify function logic to check dry-run flag before making HTTP requests.",
            "testStrategy": "Test function accepts dry-run parameter correctly. Verify function behavior changes based on dry-run flag value."
          },
          {
            "id": 8,
            "title": "Implement JSON payload construction",
            "description": "Create complete JSON payload for work item creation that matches actual API request format",
            "status": "done",
            "dependencies": [],
            "details": "Build the work item creation payload struct with all required fields (title, description, work item type, etc.). Ensure payload structure matches Azure DevOps API requirements exactly as would be sent in actual API call.",
            "testStrategy": "Test payload construction with various input combinations. Verify payload structure matches API documentation requirements."
          },
          {
            "id": 9,
            "title": "Add JSON formatting and output",
            "description": "Use json.MarshalIndent to format JSON payload for readable output to stdout in dry-run mode",
            "status": "done",
            "dependencies": [],
            "details": "Import json package and use json.MarshalIndent() with proper indentation (2 spaces). Print formatted JSON to stdout using fmt.Print() or similar. Handle any marshaling errors gracefully.",
            "testStrategy": "Test JSON formatting produces readable, properly indented output. Verify output goes to stdout and not stderr."
          },
          {
            "id": 10,
            "title": "Implement early exit for dry-run mode",
            "description": "Exit successfully after printing payload without making HTTP request when in dry-run mode",
            "status": "done",
            "dependencies": [],
            "details": "Add conditional logic to exit with status 0 after printing JSON payload when dry-run flag is set. Ensure no HTTP requests are made and no further processing occurs in dry-run mode.",
            "testStrategy": "Test that dry-run mode exits successfully without making API calls. Verify no HTTP requests are attempted when dry-run flag is set."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Work Item URL Output",
        "description": "Add functionality to output the created work item URL to stdout upon successful creation using the azure-devops-go-api library",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "details": "Extract work item URL from the workitemtracking.WorkItem object returned by the azure-devops-go-api CreateWorkItem function. The WorkItem object contains both ID and URL fields that can be used directly. Output URL to stdout on successful work item creation. Ensure URL output is the only stdout output (except in dry-run mode) for script-friendly usage.",
        "testStrategy": "Test URL extraction from WorkItem object with different work item types. Verify URL format matches Azure DevOps web interface URLs. Test that only URL is output to stdout on success.",
        "subtasks": [
          {
            "id": 1,
            "title": "Extract Work Item URL from azure-devops-go-api Response",
            "description": "Extract the work item URL from the workitemtracking.WorkItem object returned by CreateWorkItem function",
            "status": "done",
            "dependencies": [],
            "details": "Modify the createWorkItem() function to extract the URL field from the workitemtracking.WorkItem object returned by the azure-devops-go-api CreateWorkItem function. The WorkItem object contains a URL field that provides the direct link to the work item. Handle cases where the URL field might be nil or empty. Return the extracted URL along with any errors for further processing.",
            "testStrategy": "Test URL extraction from mock WorkItem objects. Test error handling for nil or empty URL fields. Verify extracted URLs match expected Azure DevOps format."
          },
          {
            "id": 2,
            "title": "Implement Stdout Output Control for URL",
            "description": "Modify output handling to ensure only the work item URL is written to stdout on successful creation",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Update the main execution flow to control stdout output. Create a dedicated function for URL output that writes directly to os.Stdout. Ensure all other informational messages (debug logs, error messages) are directed to stderr. In dry-run mode, allow JSON payload output to stdout as specified. Implement a clean separation between success output (URL to stdout) and all other output (to stderr). Use fmt.Fprintln(os.Stdout, url) for the final URL output.",
            "testStrategy": "Test that only URL appears on stdout during successful execution. Verify error messages and debug logs go to stderr. Test dry-run mode outputs JSON to stdout correctly."
          },
          {
            "id": 3,
            "title": "Integrate URL Output into Work Item Creation Flow",
            "description": "Modify the createWorkItem() function to extract URL from WorkItem object and integrate URL output into the main execution path",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Update the createWorkItem() function to extract the URL from the returned workitemtracking.WorkItem object when creation succeeds. Modify the main execution flow to output the URL to stdout after successful API response processing. Ensure the URL output only occurs after successful work item creation. Handle the case where work item creation succeeds but URL extraction fails. The integration should maintain the existing error handling while adding the new URL output functionality.",
            "testStrategy": "Test complete flow from work item creation to URL output using azure-devops-go-api. Verify URL is only output on successful creation. Test error scenarios where creation succeeds but URL extraction fails."
          },
          {
            "id": 4,
            "title": "Add URL Output Validation and Error Handling",
            "description": "Implement comprehensive error handling and validation for the URL output functionality",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Add validation to ensure the extracted URL from the WorkItem object is valid and properly formatted. Implement error handling for cases where URL extraction fails or the URL field is empty/nil. Add appropriate error messages that are sent to stderr while maintaining clean stdout output. Include validation that the URL follows the expected Azure DevOps format. Handle edge cases such as malformed URLs or missing URL fields. Ensure graceful degradation if URL output fails but work item creation succeeded.",
            "testStrategy": "Test error handling for nil or empty URL fields in WorkItem objects. Test URL validation with malformed URLs. Verify appropriate error messages are sent to stderr while stdout remains clean."
          }
        ]
      },
      {
        "id": 10,
        "title": "Integrate All Components and Add Error Handling",
        "description": "Integrate the new ADOClient with the urfave/cli application, including proper error handling and validation for the complete CLI workflow",
        "status": "done",
        "dependencies": [
          3,
          8,
          9,
          11
        ],
        "priority": "high",
        "details": "Integrate the ADOClient from Task 11 with the CLI framework from Task 3. Call NewADOClient and CreateWorkItem functions from the main command's Action handler. Handle the returned workitemtracking.WorkItem and errors properly. Add comprehensive error handling for all failure scenarios (missing env vars, invalid flags, API failures). Implement proper exit codes (0 for success, 1 for errors). Ensure error messages are clear and actionable. Add input validation for work item types and parent IDs.",
        "testStrategy": "End-to-end testing with various input combinations using the integrated ADOClient and CLI. Test all error scenarios produce appropriate error messages and exit codes. Validate against all acceptance criteria from PRD. Test example usage scenarios from PRD documentation with the azure-devops-go-api library integration.",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate ADOClient with CLI Command Action Handler",
            "description": "Implement the main command Action handler that uses NewADOClient and CreateWorkItem functions from the ADOClient implementation",
            "status": "done",
            "dependencies": [],
            "details": "Update the CLI command's Action handler to call NewADOClient() for client initialization using environment variables from config. Extract CLI flag values (type, title, description, parent) and pass them to the CreateWorkItem function. Handle the returned workitemtracking.WorkItem object and display success information. Establish proper flow: config loading -> CLI parsing -> ADOClient initialization -> work item creation -> result handling.",
            "testStrategy": "Integration tests that verify the complete flow from CLI input to work item creation using the ADOClient. Test with valid inputs to ensure successful execution path and proper handling of workitemtracking.WorkItem response."
          },
          {
            "id": 2,
            "title": "Implement Comprehensive Error Handling for ADOClient Integration",
            "description": "Create error handling that properly processes errors from ADOClient operations and provides clear user feedback",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Handle errors returned from NewADOClient() initialization (authentication, configuration issues). Process errors from CreateWorkItem() calls (API failures, validation errors, network issues). Implement proper error message formatting that interprets azure-devops-go-api error types. Set up exit code system: os.Exit(0) for success, os.Exit(1) for all error conditions. Create helper functions for consistent error reporting format that work with the library's error types.",
            "testStrategy": "Test error handling for ADOClient initialization and CreateWorkItem operation failures. Verify correct exit codes are returned and error messages properly interpret azure-devops-go-api library errors. Test various API error scenarios."
          },
          {
            "id": 3,
            "title": "Add Input Validation for Work Item Parameters",
            "description": "Implement validation for work item types, parent IDs, and other input parameters before calling ADOClient functions",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create validation functions for work item types (validate against known Azure DevOps work item types like Task, Bug, User Story, etc.). Implement parent ID validation to ensure it's a positive integer when provided. Add title and description validation for length and content requirements. Validate that required fields are not empty after trimming whitespace. Ensure validation occurs before calling CreateWorkItem to avoid unnecessary API calls.",
            "testStrategy": "Unit tests for each validation function with valid and invalid inputs. Test edge cases like empty strings, negative numbers, and unsupported work item types. Verify validation prevents invalid API calls to ADOClient."
          },
          {
            "id": 4,
            "title": "Handle WorkItem Response and Display Success Information",
            "description": "Process the workitemtracking.WorkItem response from CreateWorkItem and display relevant information to the user",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Extract relevant information from the returned workitemtracking.WorkItem object (ID, URL, title, type). Format and display success messages with work item details. Handle the case where dry-run flag is set (display what would be created without making API call). Ensure output is user-friendly and provides actionable information like work item URL for easy access.",
            "testStrategy": "Test successful work item creation response handling. Verify proper information extraction from workitemtracking.WorkItem object. Test dry-run mode output. Check that success messages are clear and include relevant work item details."
          },
          {
            "id": 5,
            "title": "Implement End-to-End Error Scenarios with Azure DevOps API Library",
            "description": "Handle specific error scenarios that can occur with the azure-devops-go-api library including authentication, network, and API-specific errors",
            "status": "done",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement specific error handling for: ADOClient initialization failures (invalid PAT, missing config), azure-devops-go-api authentication errors, network connectivity issues, invalid parent work item IDs (API validation errors), API rate limiting responses, and malformed API responses from the library. Provide actionable error messages that guide users toward resolution and properly interpret library-specific error types.",
            "testStrategy": "End-to-end testing with various failure scenarios using the azure-devops-go-api library. Mock API responses for different error conditions. Test that error messages provide clear guidance for resolution. Verify proper exit codes for all error scenarios specific to the library integration."
          }
        ]
      },
      {
        "id": 11,
        "title": "Refactor ADOClient to use Microsoft's Official azure-devops-go-api Library",
        "description": "Replace the custom HTTP client implementation in ADOClient with Microsoft's official azure-devops-go-api library to improve reliability, maintainability, and future compatibility.",
        "details": "Replace the existing custom HTTP client implementation with Microsoft's official azure-devops-go-api library. Install the library using 'go get github.com/microsoft/azure-devops-go-api/azuredevops'. Refactor the AzureDevOpsClient struct to use azuredevops.Connection instead of custom HTTP client. Replace manual authentication with the library's connection.NewPatConnection() method for PAT authentication. Update all API calls to use typed clients like workitemtracking.Client instead of manual HTTP requests. Replace custom URL construction with the library's built-in endpoint management. Update error handling to use the library's structured error types instead of custom APIError. Modify createWorkItem() function to use workitemtracking.Client.CreateWorkItem() with proper JsonPatchDocument operations. Update getUserFromPAT() function to use the library's profile or identity clients. Ensure all existing functionality (work item creation, user lookup, dry-run mode) continues to work with the new implementation. Update import statements and remove custom HTTP handling code. Maintain backward compatibility with existing configuration and environment variables.",
        "testStrategy": "Update unit tests to work with the new library implementation. Test PAT authentication using the official library's connection methods. Verify work item creation functionality produces identical results to the previous implementation. Test error handling with the library's error types. Validate that all existing CLI functionality (dry-run mode, user assignment, URL output) works correctly with the refactored client. Run integration tests against test Azure DevOps instance to ensure API compatibility. Test with various work item types and parent assignments. Verify that the refactored implementation handles network failures and API errors gracefully. Compare performance and reliability with the previous custom implementation.",
        "status": "done",
        "dependencies": [
          5,
          6,
          7
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Integrate azure-devops-go-api Library",
            "description": "Add the official azure-devops-go-api library to the project and ensure it is properly imported and available for use in the codebase.",
            "dependencies": [],
            "details": "Run 'go get github.com/microsoft/azure-devops-go-api/azuredevops' to install the library. Update import statements in relevant files to use the new library. Remove any unused custom HTTP client imports.\n<info added on 2025-07-29T19:50:24.243Z>\nLibrary installation completed successfully. Azure DevOps Go API v1.0.0-b5 and google/uuid dependency are now available in the project. Import statements can be updated and client refactoring can begin.\n</info added on 2025-07-29T19:50:24.243Z>",
            "status": "done",
            "testStrategy": "Verify that the project builds successfully and that the azure-devops-go-api package is present in go.mod and go.sum."
          },
          {
            "id": 2,
            "title": "Refactor AzureDevOpsClient Struct and Authentication",
            "description": "Modify the AzureDevOpsClient struct to use azuredevops.Connection and implement authentication using connection.NewPatConnection().",
            "dependencies": [
              "11.1"
            ],
            "details": "Replace the custom HTTP client field in AzureDevOpsClient with an azuredevops.Connection field. Update the client initialization logic to use connection.NewPatConnection() for PAT authentication, removing manual header and base64 logic.\n<info added on 2025-07-29T19:52:10.469Z>\nSuccessfully refactored ADOClient struct and authentication to use the official azure-devops-go-api library:\n\n- Replaced custom HTTP client with azuredevops.Connection using NewPatConnection()\n- Added workitemtracking.Client field for typed work item operations\n- Removed all manual HTTP handling, authentication encoding, URL construction, and custom error types\n- Updated NewADOClient constructor to use the official library's connection management\n- Eliminated custom headers, transport, and request logic - now handled by the library\n- Code builds successfully and is ready for implementing typed API calls\n\nThe client now uses the official Microsoft library for all Azure DevOps interactions, providing better reliability and maintainability.\n</info added on 2025-07-29T19:52:10.469Z>",
            "status": "done",
            "testStrategy": "Test that the client initializes successfully with valid and invalid PATs, and that authentication errors are handled using the library's error types."
          },
          {
            "id": 3,
            "title": "Replace Manual API Calls with Typed Clients",
            "description": "Update all API interactions to use the official library's typed clients (e.g., workitemtracking.Client) instead of manual HTTP requests and custom URL construction.",
            "dependencies": [
              "11.2"
            ],
            "details": "Identify all places where manual HTTP requests are made (such as work item creation and user lookup). Refactor these to use the corresponding typed clients and methods provided by azure-devops-go-api, leveraging built-in endpoint management.",
            "status": "done",
            "testStrategy": "Verify that all API calls (work item creation, user lookup, etc.) function correctly and produce the same results as the previous implementation."
          },
          {
            "id": 4,
            "title": "Update Error Handling to Use Library Types",
            "description": "Refactor error handling throughout the client to use the structured error types provided by azure-devops-go-api instead of custom APIError types.",
            "dependencies": [
              "11.3"
            ],
            "details": "Replace custom error type definitions and usages with the error types returned by the official library. Ensure that error messages and codes are handled and surfaced appropriately.",
            "status": "done",
            "testStrategy": "Test error scenarios (e.g., invalid PAT, network failures, API errors) and confirm that errors are handled and reported using the library's structured types."
          },
          {
            "id": 5,
            "title": "Remove Legacy Code and Ensure Backward Compatibility",
            "description": "Clean up the codebase by removing all custom HTTP handling, legacy authentication, and manual endpoint logic. Ensure that configuration and environment variable usage remains compatible with existing setups.",
            "dependencies": [
              "11.4"
            ],
            "details": "Delete unused custom HTTP client code, manual authentication, and URL construction helpers. Review configuration and environment variable handling to ensure no breaking changes are introduced. Update documentation as needed.",
            "status": "done",
            "testStrategy": "Run all existing unit and integration tests to confirm that all features (work item creation, user lookup, dry-run mode) continue to work as before. Validate that configuration and environment variables are still honored."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Error Classification Helpers for Azure DevOps Go SDK Integration",
        "description": "Create error classification helper functions to categorize different types of errors from the Azure DevOps Go SDK and standard library using Go error unwrapping and type assertions.",
        "details": "Implement five error classification helper functions in a dedicated errors.go file: isAuthError(), isNetworkError(), isValidationError(), isRateLimitError(), and isMalformedResponseError(). Each function should accept an error parameter and return a boolean indicating if the error belongs to that category. Use Go's errors.Unwrap() and errors.As() functions to traverse error chains and perform type assertions against azure-devops-go-api error types and standard library errors. For authentication errors, check for HTTP 401/403 status codes and azure-devops-go-api authentication-related error types. For network errors, detect net.Error types, context.DeadlineExceeded, and connection-related errors. For validation errors, look for HTTP 400 status codes and field validation error patterns. For rate limiting, identify HTTP 429 status codes and rate limit error messages. For malformed response errors, catch JSON unmarshaling errors and unexpected response format issues. Each helper should use a switch statement or type assertion chain to check multiple error conditions, ensuring comprehensive error detection across the SDK and standard library error hierarchy.",
        "testStrategy": "Create comprehensive unit tests for each error classification function using table-driven tests with various error scenarios. Test each helper with: wrapped errors using fmt.Errorf(), azure-devops-go-api specific error types, standard library errors (net.Error, json.SyntaxError, etc.), HTTP status code errors, and nil error cases. Mock different error conditions including authentication failures (401/403), network timeouts, validation failures (400), rate limiting (429), and JSON parsing errors. Verify that error unwrapping works correctly through multiple error layers. Test edge cases like custom error types and ensure helpers return false for unrelated error types. Validate that the helpers can correctly identify errors in real integration scenarios with the Azure DevOps API.",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Error Categories and Mapping Criteria",
            "description": "Identify and document the specific error types and patterns for each classification category (authentication, network, validation, rate limit, malformed response) based on Azure DevOps Go SDK and Go standard library error types.",
            "dependencies": [],
            "details": "Research Azure DevOps Go SDK error types and standard library errors. Specify criteria for each helper, such as HTTP status codes, error interfaces (e.g., net.Error), and error message patterns. Document these mappings for use in implementation.",
            "status": "done",
            "testStrategy": "Review SDK and standard library documentation. Create a mapping table of error types and their corresponding categories."
          },
          {
            "id": 2,
            "title": "Implement isAuthError Helper Function",
            "description": "Develop the isAuthError(error) bool function to detect authentication-related errors using error unwrapping, type assertions, and HTTP status code checks.",
            "dependencies": [
              "12.1"
            ],
            "details": "Use errors.Unwrap() and errors.As() to traverse error chains. Check for Azure DevOps SDK authentication error types and HTTP 401/403 status codes. Ensure comprehensive coverage of possible authentication error scenarios.",
            "status": "done",
            "testStrategy": "Write unit tests with various authentication error cases, including wrapped errors and SDK-specific types."
          },
          {
            "id": 3,
            "title": "Implement isNetworkError Helper Function",
            "description": "Develop the isNetworkError(error) bool function to identify network-related errors, including net.Error, context.DeadlineExceeded, and connection issues.",
            "dependencies": [
              "12.1"
            ],
            "details": "Use errors.As() to check for net.Error, context.DeadlineExceeded, and connection reset errors. Traverse error chains to detect nested network errors.",
            "status": "done",
            "testStrategy": "Test with simulated network errors, including wrapped net.Error, context errors, and connection failures."
          },
          {
            "id": 4,
            "title": "Implement isValidationError, isRateLimitError, and isMalformedResponseError Helper Functions",
            "description": "Develop the remaining three helper functions to classify validation, rate limit, and malformed response errors using error unwrapping, type assertions, and pattern matching.",
            "dependencies": [
              "12.1"
            ],
            "details": "For isValidationError, check for HTTP 400 status codes and validation error patterns. For isRateLimitError, detect HTTP 429 status codes and rate limit messages. For isMalformedResponseError, identify JSON unmarshaling errors and unexpected response formats.",
            "status": "done",
            "testStrategy": "Create unit tests for each function with relevant error scenarios, including wrapped and SDK-specific errors."
          },
          {
            "id": 5,
            "title": "Integrate and Document Error Helpers in errors.go",
            "description": "Combine all helper functions into a dedicated errors.go file, ensure code consistency, and provide inline documentation for maintainability.",
            "dependencies": [
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Place all error classification helpers in errors.go. Add comments explaining logic and usage. Ensure functions are exported or unexported as appropriate for project structure.",
            "status": "done",
            "testStrategy": "Run all unit tests for the helpers. Review documentation for clarity and completeness."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Unified Error Handler Function for CLI",
        "description": "Create a centralized handleError function that uses error classification helpers to detect error types, outputs user-friendly messages to stderr, and exits with code 1 while optionally logging technical details for diagnostics.",
        "details": "Implement a handleError(err error) function in a dedicated error_handler.go file that serves as the single point of error handling for the CLI application. The function should: 1) Use the error classification helpers from Task 12 (isAuthError, isNetworkError, isValidationError, isRateLimitError, isMalformedResponseError) to categorize the error type, 2) Map each error category to user-friendly, actionable messages that guide users toward resolution without exposing sensitive information like PAT tokens or internal API details, 3) Write all error messages to stderr using fmt.Fprintf(os.Stderr, ...), 4) Optionally log technical error details (stack traces, raw error messages) to stderr when DEBUG environment variable is set, following the debug logging patterns, 5) Always exit with os.Exit(1) after handling the error, 6) Include a fallback case for unclassified errors with a generic but helpful message. Error messages should be structured as: \"Error: [user-friendly description]\" followed by \"Suggestion: [actionable next step]\". For authentication errors, suggest checking PAT validity and permissions. For network errors, suggest checking connectivity and Azure DevOps service status. For validation errors, provide specific guidance on fixing input parameters. Ensure no sensitive data (PATs, internal URLs, stack traces) appears in user-facing messages unless DEBUG mode is enabled.",
        "testStrategy": "Create comprehensive unit tests using table-driven tests that cover each error classification scenario. Test handleError with mock errors of each type (auth, network, validation, rate limit, malformed response) and verify correct user-friendly messages are written to stderr. Test that technical details are only logged when DEBUG environment variable is set. Verify that os.Exit(1) is called in all cases using testable exit patterns or dependency injection. Test fallback handling for unclassified errors. Verify no sensitive information leaks in error messages by testing with errors containing PAT tokens, internal URLs, and stack traces. Test integration with the CLI application by replacing direct error handling in Task 10's integration points with calls to handleError function.",
        "status": "done",
        "dependencies": [
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Error Classification Helpers",
            "description": "Incorporate the error classification helpers (isAuthError, isNetworkError, isValidationError, isRateLimitError, isMalformedResponseError) from Task 12 into the handleError function to accurately categorize incoming errors.",
            "dependencies": [],
            "details": "Ensure handleError uses each helper to determine the error type, supporting future extensibility for new error categories.",
            "status": "done",
            "testStrategy": "Provide mock errors for each category and verify correct classification logic is invoked."
          },
          {
            "id": 2,
            "title": "Map Error Categories to User-Friendly Messages",
            "description": "Define and implement mappings from each error category to a user-friendly error message and actionable suggestion, ensuring no sensitive information is exposed.",
            "dependencies": [
              "13.1"
            ],
            "details": "Craft messages that guide users toward resolution, such as checking PAT validity for authentication errors or verifying connectivity for network errors. Ensure fallback messaging for unclassified errors.",
            "status": "done",
            "testStrategy": "Test that each error type produces the correct message and suggestion, and that fallback messaging is used for unknown errors."
          },
          {
            "id": 3,
            "title": "Implement Structured Error Output to Stderr",
            "description": "Write logic in handleError to output error messages and suggestions to stderr using fmt.Fprintf(os.Stderr, ...), following the required message structure.",
            "dependencies": [
              "13.2"
            ],
            "details": "Ensure all user-facing error output is consistently formatted as 'Error: [description]' and 'Suggestion: [actionable next step]'.",
            "status": "done",
            "testStrategy": "Capture stderr output in tests and verify message structure and content for each error scenario."
          },
          {
            "id": 4,
            "title": "Add Conditional Debug Logging for Technical Details",
            "description": "Implement logic to optionally log technical error details (such as stack traces or raw error messages) to stderr when the DEBUG environment variable is set, following established debug logging patterns.",
            "dependencies": [
              "13.3"
            ],
            "details": "Ensure technical details are only included in stderr output when DEBUG is enabled, and that no sensitive data appears in user-facing messages.",
            "status": "done",
            "testStrategy": "Test with DEBUG set and unset, verifying technical details are present only when expected and that sensitive data is never leaked."
          },
          {
            "id": 5,
            "title": "Enforce Application Exit and Fallback Handling",
            "description": "Ensure handleError always calls os.Exit(1) after handling the error, and includes a robust fallback for unclassified errors with a generic but helpful message.",
            "dependencies": [
              "13.4"
            ],
            "details": "Guarantee that all error paths result in process termination and that the fallback case provides guidance without exposing internal details.",
            "status": "done",
            "testStrategy": "Test that handleError always exits with code 1 and that fallback messaging is triggered for unknown error types."
          }
        ]
      },
      {
        "id": 14,
        "title": "Refactor CLI Error Handling to Use Unified Error Handler",
        "description": "Replace all direct cli.Exit(err, 1) and similar error handling calls throughout the CLI codebase with the unified handleError(err) function to ensure consistent error handling and user experience.",
        "details": "Systematically refactor all CLI error handling to use the unified error handler from Task 13. This involves: 1) Identifying and replacing all instances of direct cli.Exit(err, 1), os.Exit(1), log.Fatal(), and similar error handling patterns with calls to handleError(err), 2) Updating the action and actionWithClient functions in the CLI framework to use handleError() instead of returning errors directly to the CLI framework, 3) Ensuring all errors from ADOClient operations (NewADOClient, CreateWorkItem) are passed through handleError() rather than being handled inline, 4) Refactoring error handling in the main command's Action handler to use handleError() for all failure scenarios including missing environment variables, invalid flags, and API failures, 5) Removing redundant error message formatting since handleError() now provides user-friendly messages, 6) Ensuring that handleError() is called consistently across all error paths in the application, 7) Updating any custom error handling logic to leverage the error classification and unified messaging provided by handleError(). The refactoring should maintain the same exit codes (0 for success, 1 for errors) while providing more consistent and user-friendly error messages through the unified handler.",
        "testStrategy": "Create integration tests that verify all error paths now use the unified error handler by: 1) Testing each error scenario (authentication failures, network errors, validation errors, rate limiting, malformed responses) and confirming they produce the expected user-friendly messages from handleError(), 2) Verifying that no direct cli.Exit() or os.Exit() calls remain in the codebase through static code analysis or grep searches, 3) Testing that all ADOClient errors are properly passed through handleError() by mocking various error conditions from the azure-devops-go-api library, 4) Confirming that action and actionWithClient functions no longer return errors to the CLI framework but instead call handleError() directly, 5) End-to-end testing of the complete CLI workflow to ensure error handling is consistent across all commands and scenarios, 6) Verifying that technical error details are logged appropriately while user-facing messages remain clear and actionable, 7) Testing edge cases where multiple errors might occur to ensure handleError() is called for the appropriate error in the chain.",
        "status": "cancelled",
        "dependencies": [
          13,
          10
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify All Direct Error Handling Calls in CLI Codebase",
            "description": "Systematically search the CLI codebase to locate all instances of direct error handling calls such as cli.Exit(err, 1), os.Exit(1), log.Fatal(), and similar patterns that bypass the unified error handler.",
            "dependencies": [],
            "details": "Use code search tools or IDE features to find all direct process exit and fatal error calls. Document each instance with file and line references for targeted refactoring.",
            "status": "cancelled",
            "testStrategy": "Verify completeness by running static analysis or grep scripts to ensure no direct exit or fatal calls remain after refactoring."
          },
          {
            "id": 2,
            "title": "Refactor Error Handling Calls to Use handleError(err)",
            "description": "Replace all identified direct error handling calls with calls to the unified handleError(err) function to ensure consistent error processing and messaging.",
            "dependencies": [
              "14.1"
            ],
            "details": "Update each code location to remove direct exit or fatal calls and invoke handleError(err) instead. Ensure that error propagation and exit codes remain consistent with previous behavior.",
            "status": "cancelled",
            "testStrategy": "Run integration tests for each CLI command to confirm that errors are routed through handleError and that exit codes are preserved."
          },
          {
            "id": 3,
            "title": "Update CLI Framework Functions to Use Unified Error Handler",
            "description": "Modify the action and actionWithClient functions in the CLI framework to utilize handleError(err) for error handling instead of returning errors directly to the framework.",
            "dependencies": [
              "14.2"
            ],
            "details": "Refactor framework-level handlers so that all errors are passed to handleError, ensuring that user-facing error messages are consistent and technical details are logged as appropriate.",
            "status": "cancelled",
            "testStrategy": "Test CLI actions that previously returned errors to the framework and confirm that all errors are now processed by handleError with correct output."
          },
          {
            "id": 4,
            "title": "Refactor Main Command and ADOClient Error Handling",
            "description": "Update the main command's Action handler and all ADOClient operation error handling (e.g., NewADOClient, CreateWorkItem) to use handleError(err) for all failure scenarios, including environment validation, flag errors, and API failures.",
            "dependencies": [
              "14.3"
            ],
            "details": "Ensure that all error paths in the main command and ADOClient logic are routed through handleError, removing any redundant error formatting or inline handling.",
            "status": "cancelled",
            "testStrategy": "Create and run integration tests for scenarios such as missing environment variables, invalid flags, and API errors, verifying that handleError produces the expected user-friendly messages."
          },
          {
            "id": 5,
            "title": "Remove Redundant Error Formatting and Ensure Consistency",
            "description": "Eliminate any redundant or obsolete error message formatting now handled by handleError, and review all error paths to confirm consistent use of the unified error handler throughout the CLI application.",
            "dependencies": [
              "14.4"
            ],
            "details": "Audit the codebase for leftover custom error formatting or legacy error handling logic. Refactor or remove as needed to ensure all errors are processed by handleError and messaging is unified.",
            "status": "cancelled",
            "testStrategy": "Perform a final code review and run full CLI test suites to confirm that all error messages are consistent, user-friendly, and no direct exit or custom formatting remains."
          }
        ]
      },
      {
        "id": 15,
        "title": "Add Unit Tests for Error Classification Helpers",
        "description": "Create comprehensive unit tests for each error classification helper function (isAuthError, isNetworkError, isValidationError, isRateLimitError, isMalformedResponseError) with mock error scenarios and edge case coverage.",
        "details": "Implement comprehensive unit tests for all five error classification helper functions from Task 12. Create a dedicated errors_test.go file with table-driven tests for each helper function. For each classification helper, create test cases that cover: 1) Direct error type matches (e.g., testing isAuthError with actual authentication errors from azure-devops-go-api), 2) Wrapped error scenarios using fmt.Errorf() and custom error wrapping to ensure the helpers can traverse error chains using errors.Unwrap(), 3) Standard library error types (net.Error for network errors, json.SyntaxError for malformed response errors), 4) HTTP status code based errors (401/403 for auth, 429 for rate limiting, 400/422 for validation), 5) Azure DevOps SDK specific error types and their proper identification, 6) Edge cases including nil errors, empty error messages, and deeply nested error chains. Use testify/mock or similar mocking framework to create controlled error scenarios. Each test should verify both positive cases (correct error type identification) and negative cases (ensuring helpers don't misclassify errors). Include benchmarks for performance testing of error classification logic. Add test coverage reporting to ensure all code paths in the helper functions are tested.",
        "testStrategy": "Execute unit tests using 'go test -v ./...' and verify 100% test coverage for all error classification helpers using 'go test -cover'. Run table-driven tests for each helper function with at least 10 different error scenarios per function. Validate that each helper correctly identifies its target error type while rejecting other error types. Test error unwrapping functionality by creating nested error chains and ensuring helpers can traverse them. Use mock objects to simulate azure-devops-go-api errors and verify proper type assertion behavior. Run benchmarks to ensure error classification performance is acceptable. Verify test isolation by running tests in random order and parallel execution. Test edge cases including nil inputs, malformed error structures, and extremely deep error chains to ensure robust error handling.",
        "status": "cancelled",
        "dependencies": [
          12
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up errors_test.go and Table-Driven Test Structure",
            "description": "Create a new errors_test.go file and define table-driven test functions for each error classification helper (isAuthError, isNetworkError, isValidationError, isRateLimitError, isMalformedResponseError). Establish a consistent structure for test case definitions and result assertions.",
            "dependencies": [],
            "details": "Initialize the test file in the appropriate package. For each helper, define a table of test cases with input errors and expected boolean results. Use Go's testing framework and testify/assert for assertions.",
            "status": "cancelled",
            "testStrategy": "Verify that the test file compiles and runs with 'go test', and that each helper has a corresponding table-driven test function."
          },
          {
            "id": 2,
            "title": "Implement Direct and Wrapped Error Type Test Cases",
            "description": "Add test cases for each helper covering direct error type matches and wrapped error scenarios. Use actual error types from azure-devops-go-api, standard library, and custom errors. Include cases with errors wrapped using fmt.Errorf and errors.Unwrap.",
            "dependencies": [
              "15.1"
            ],
            "details": "For each helper, create test cases with direct error instances (e.g., authentication errors for isAuthError) and errors wrapped in multiple layers. Ensure the helpers correctly traverse error chains.",
            "status": "cancelled",
            "testStrategy": "Run tests to confirm that helpers identify both direct and wrapped error types as expected, and do not misclassify unrelated errors."
          },
          {
            "id": 3,
            "title": "Add HTTP Status Code and SDK-Specific Error Test Cases",
            "description": "Develop test cases for error helpers that involve HTTP status code-based errors (e.g., 401/403 for auth, 429 for rate limiting, 400/422 for validation) and Azure DevOps SDK-specific error types. Ensure correct identification and negative case coverage.",
            "dependencies": [
              "15.2"
            ],
            "details": "Simulate errors with relevant HTTP status codes and Azure DevOps SDK error types. Include both positive (should match) and negative (should not match) scenarios for each helper.",
            "status": "cancelled",
            "testStrategy": "Validate that helpers correctly classify errors based on status codes and SDK types, and do not misclassify unrelated status codes or error types."
          },
          {
            "id": 4,
            "title": "Test Edge Cases and Deeply Nested Error Chains",
            "description": "Create test cases for edge conditions, including nil errors, empty error messages, and deeply nested error chains. Ensure helpers handle these scenarios gracefully and maintain correct classification.",
            "dependencies": [
              "15.3"
            ],
            "details": "Add cases where the error is nil, the error message is empty, or the error is nested several layers deep. Use testify/mock or similar to create controlled error scenarios.",
            "status": "cancelled",
            "testStrategy": "Confirm that helpers return false for nil and irrelevant errors, and true for deeply nested matching errors. Ensure no panics or unexpected behavior."
          },
          {
            "id": 5,
            "title": "Add Benchmarks and Test Coverage Reporting",
            "description": "Implement benchmark tests for each error classification helper to measure performance. Integrate test coverage reporting to ensure all code paths are exercised.",
            "dependencies": [
              "15.4"
            ],
            "details": "Write benchmark functions for each helper using Go's testing.B. Run 'go test -cover' to check coverage and ensure 100% coverage for all helpers.",
            "status": "cancelled",
            "testStrategy": "Run benchmarks with 'go test -bench=.' and verify performance is acceptable. Use 'go test -cover' to confirm full code path coverage."
          }
        ]
      },
      {
        "id": 16,
        "title": "Add Integration and Subprocess Tests for CLI Error Output and Exit Codes",
        "description": "Create comprehensive integration and subprocess tests to verify that the CLI outputs actionable error messages to stderr and exits with code 1 for each error class, ensuring no sensitive data is leaked in error output.",
        "details": "Implement integration and subprocess tests in a dedicated cli_error_integration_test.go file that validates the complete CLI error handling workflow. Create test scenarios for each error classification: authentication errors (invalid PAT, expired tokens), network errors (connection timeouts, DNS failures), validation errors (invalid work item types, missing required fields), rate limit errors (429 responses), and malformed response errors (invalid JSON, unexpected API responses). Use Go's os/exec package to spawn CLI subprocesses and capture both stdout, stderr, and exit codes. For each error class, create test cases that: 1) Trigger the specific error condition using mock servers or invalid inputs, 2) Verify the CLI exits with code 1, 3) Confirm error messages are written to stderr (not stdout), 4) Validate that error messages are user-friendly and actionable without exposing sensitive information like PAT tokens, internal URLs, or stack traces, 5) Test both direct SDK errors and wrapped errors to ensure proper error chain handling. Implement helper functions to set up mock Azure DevOps servers that return specific HTTP status codes and error responses. Create test utilities to validate that stderr output contains expected keywords (e.g., \"authentication failed\", \"network error\", \"invalid work item type\") while ensuring no sensitive data patterns are present. Include tests for edge cases like partial network failures, malformed JSON responses, and unexpected HTTP status codes.",
        "testStrategy": "Execute integration tests using 'go test -v ./... -tags=integration' to run subprocess tests that spawn actual CLI instances. For each error class, verify: 1) CLI process exits with code 1 using cmd.ProcessState.ExitCode(), 2) Error messages appear on stderr using cmd.StderrPipe(), 3) No output appears on stdout except in specific scenarios, 4) Error messages contain actionable guidance without sensitive data using regex pattern matching. Create mock HTTP servers using httptest.Server to simulate Azure DevOps API error responses (401, 403, 429, 500, malformed JSON). Test error message content by searching for expected phrases and ensuring absence of sensitive patterns like PAT tokens, internal stack traces, or system paths. Validate that wrapped errors from the azure-devops-go-api library are properly handled and produce the same user-friendly output as direct errors. Run tests with various environment configurations (missing env vars, invalid URLs, network timeouts) to ensure comprehensive error scenario coverage. Use table-driven tests to systematically cover all error classifications and verify consistent error handling behavior across different failure modes.",
        "status": "cancelled",
        "dependencies": [
          14,
          13,
          12
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Test Scenarios for Each CLI Error Classification",
            "description": "Identify and document specific test cases for each error class: authentication errors (invalid PAT, expired tokens), network errors (timeouts, DNS failures), validation errors (invalid work item types, missing fields), rate limit errors (429 responses), and malformed response errors (invalid JSON, unexpected API responses).",
            "dependencies": [],
            "details": "Enumerate all error conditions to be simulated, ensuring coverage of both direct SDK errors and wrapped errors. Specify expected error messages and exit codes for each scenario.",
            "status": "cancelled",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Mock Servers and Input Generators for Error Simulation",
            "description": "Develop mock Azure DevOps servers and input generators to reliably trigger each error condition identified in the test scenarios.",
            "dependencies": [
              "16.1"
            ],
            "details": "Set up HTTP servers to return specific status codes and error payloads. Create utilities to generate invalid tokens, malformed requests, and simulate network failures for subprocess testing.",
            "status": "cancelled",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Integration and Subprocess Test Harness Using os/exec",
            "description": "Create the cli_error_integration_test.go file and implement test harness logic to spawn CLI subprocesses, capture stdout, stderr, and exit codes for each scenario.",
            "dependencies": [
              "16.2"
            ],
            "details": "Use Go's os/exec package to run the CLI with various inputs and environment settings. Ensure tests can capture and analyze process output and exit status for validation.",
            "status": "cancelled",
            "testStrategy": "For each error scenario, run the CLI as a subprocess, capture outputs, and assert correct exit code and error stream usage."
          },
          {
            "id": 4,
            "title": "Validate Error Output for Actionability and Sensitive Data Leakage",
            "description": "Implement assertions to verify that error messages are actionable, appear only on stderr, and do not leak sensitive information such as PAT tokens, internal URLs, or stack traces.",
            "dependencies": [
              "16.3"
            ],
            "details": "Create helper functions to scan stderr for required keywords and patterns, and to check for the absence of sensitive data using regex or string matching.",
            "status": "cancelled",
            "testStrategy": "For each test, assert that stderr contains expected error phrases and does not match any sensitive data patterns."
          },
          {
            "id": 5,
            "title": "Test Edge Cases and Error Chain Handling",
            "description": "Add tests for edge cases such as partial network failures, malformed JSON responses, unexpected HTTP status codes, and ensure proper handling of both direct and wrapped errors.",
            "dependencies": [
              "16.4"
            ],
            "details": "Expand test coverage to include rare or complex failure modes and verify that error chains are correctly unwrapped and reported to the user.",
            "status": "cancelled",
            "testStrategy": "Simulate edge conditions and assert that the CLI's error output and exit codes remain correct and secure."
          }
        ]
      },
      {
        "id": 17,
        "title": "Document CLI Error Messages and Resolutions in README and Help Output",
        "description": "Create comprehensive documentation for all CLI error messages and their resolutions in both the README file and CLI help output, providing clear, actionable guidance for common errors without exposing sensitive information.",
        "details": "Create comprehensive error documentation in two locations: 1) Add a \"Troubleshooting\" section to the README.md file with detailed error scenarios and resolutions, organized by error category (Authentication, Network, Validation, Rate Limiting, Malformed Responses). For each category, document common error messages users will see, root causes, and step-by-step resolution instructions. Include examples like \"Error: Authentication failed\" with solutions such as \"Verify your Personal Access Token is valid and has appropriate permissions\" and \"Check that your PAT hasn't expired in Azure DevOps settings\". 2) Enhance CLI help output by adding a --help-errors flag or similar mechanism that displays condensed troubleshooting information directly in the terminal. Ensure all documentation follows these principles: use clear, non-technical language accessible to all users; provide actionable steps rather than generic advice; include links to relevant Azure DevOps documentation; never expose sensitive data like actual PAT values, internal error codes, or system paths; organize content logically with consistent formatting; include common scenarios like network connectivity issues, permission problems, and API rate limiting. The documentation should reference the error classification system and unified error handler to ensure consistency between actual error messages and documented solutions.",
        "testStrategy": "Verify documentation completeness by cross-referencing with error classification helpers from Task 12 to ensure all error categories are documented. Test that each documented error scenario matches the actual error messages produced by the unified error handler from Task 13. Validate that resolution steps are actionable by following them in test environments. Review documentation for sensitive data exposure using automated scanning tools and manual review. Test the CLI help output functionality (--help-errors or similar) to ensure it displays correctly formatted troubleshooting information. Conduct user testing with the documentation to verify clarity and effectiveness of resolution steps. Ensure all external links (Azure DevOps documentation) are valid and current. Verify that documentation formatting is consistent and renders properly in both README markdown and CLI terminal output.",
        "status": "cancelled",
        "dependencies": [
          13,
          12
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Gather and Categorize CLI Error Messages",
            "description": "Collect all possible CLI error messages generated by the application, referencing the unified error handler and error classification system. Organize these errors into categories such as Authentication, Network, Validation, Rate Limiting, and Malformed Responses.",
            "dependencies": [],
            "details": "Review the CLI codebase and error handler to extract every user-facing error message. Assign each error to a logical category for documentation consistency.",
            "status": "cancelled",
            "testStrategy": "Cross-reference the collected errors with the error classification helpers and unified error handler to ensure completeness and accuracy."
          },
          {
            "id": 2,
            "title": "Draft Troubleshooting Section for README.md",
            "description": "Create a detailed 'Troubleshooting' section in README.md, documenting each error category with common error messages, root causes, and step-by-step resolution instructions. Ensure language is clear, actionable, and non-technical.",
            "dependencies": [
              "17.1"
            ],
            "details": "For each error, provide a user-friendly explanation, actionable resolution steps, and example scenarios. Include references to relevant Azure DevOps documentation where appropriate.",
            "status": "cancelled",
            "testStrategy": "Review the README to confirm all error categories and messages are covered, and that instructions are clear and actionable for non-technical users."
          },
          {
            "id": 3,
            "title": "Implement --help-errors Flag in CLI",
            "description": "Enhance the CLI help output by adding a --help-errors flag (or similar mechanism) that displays condensed troubleshooting information for common errors directly in the terminal.",
            "dependencies": [
              "17.1"
            ],
            "details": "Design the help output to summarize error categories, common messages, and concise resolution steps, ensuring consistency with the README documentation.",
            "status": "cancelled",
            "testStrategy": "Test the CLI with the --help-errors flag to verify that all documented errors are included, information is concise, and formatting is clear."
          },
          {
            "id": 4,
            "title": "Ensure Documentation Consistency and Security",
            "description": "Review both the README and CLI help output to ensure error documentation is consistent, follows the error classification system, and does not expose sensitive information such as PAT values, internal codes, or system paths.",
            "dependencies": [
              "17.2",
              "17.3"
            ],
            "details": "Perform a thorough audit of all documentation content for consistency, logical organization, and security best practices.",
            "status": "cancelled",
            "testStrategy": "Validate that no sensitive data is present and that all error messages and resolutions are aligned between the README and CLI help output."
          },
          {
            "id": 5,
            "title": "Validate Documentation Against Actual CLI Behavior",
            "description": "Test the CLI to trigger each documented error scenario, confirming that the error messages and suggested resolutions in the documentation match the actual CLI output and behavior.",
            "dependencies": [
              "17.4"
            ],
            "details": "Systematically reproduce each error using the CLI, comparing the observed output to the documentation for accuracy and completeness.",
            "status": "cancelled",
            "testStrategy": "For each error scenario, verify that the documentation provides correct guidance and that the CLI output matches the documented messages and solutions."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-29T13:43:10.913Z",
      "updated": "2025-07-29T22:15:42.793Z",
      "description": "Tasks for master context"
    }
  },
  "sprint-2025-07-30": {
    "tasks": [
      {
        "id": 1,
        "title": "Sanitize Sensitive Data in Dry Run Output",
        "description": "Implement data sanitization for dry-run mode output to prevent exposure of sensitive information like Personal Access Tokens and user data in stdout logs.",
        "details": "This critical security task requires implementing a comprehensive data sanitization system for dry-run output. The solution should include: 1) Create a sanitization function that identifies and redacts sensitive fields such as Personal Access Tokens (PATs), API keys, passwords, email addresses, and user identifiers in the assignedTo field. 2) Implement pattern matching to detect common sensitive data formats (e.g., GitHub tokens starting with 'ghp_', 'gho_', etc.). 3) Replace sensitive values with placeholder text like '[REDACTED]' or '[SENSITIVE_DATA_HIDDEN]' while preserving the structure for debugging purposes. 4) Add a configuration option to control sanitization level (strict/moderate/disabled) with strict as default. 5) Include a prominent warning message when dry-run mode is enabled, alerting users about potential sensitive data exposure. 6) Ensure the sanitization works across different output formats (JSON, YAML, plain text). 7) Consider implementing a whitelist approach for known safe fields to minimize false positives. The implementation should be performant and not significantly impact dry-run execution time.",
        "testStrategy": "Testing should include: 1) Unit tests with mock patch documents containing various types of sensitive data (PATs, API keys, email addresses, user IDs) to verify proper redaction. 2) Integration tests running dry-run mode with real-world patch examples to ensure output is sanitized without breaking functionality. 3) Performance tests to measure sanitization overhead on large patch documents. 4) Security tests attempting to bypass sanitization with edge cases like encoded data, nested objects, and unusual formatting. 5) Configuration tests verifying different sanitization levels work correctly. 6) User experience tests ensuring warning messages are displayed appropriately and redacted output remains useful for debugging. 7) Regression tests to ensure existing dry-run functionality remains intact. 8) Manual testing with actual sensitive data in a controlled environment to validate real-world effectiveness.",
        "status": "cancelled",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Sensitive Data Pattern Matching",
            "description": "Develop robust pattern matching logic to identify sensitive data types such as Personal Access Tokens (PATs), API keys, passwords, email addresses, and user identifiers (e.g., assignedTo field) in dry-run output.",
            "dependencies": [],
            "details": "Define regular expressions and detection rules for common sensitive data formats, including but not limited to GitHub tokens (e.g., 'ghp_', 'gho_'), email patterns, and typical API key structures. Ensure extensibility for future sensitive data types.",
            "status": "cancelled",
            "testStrategy": "Create unit tests with mock outputs containing various sensitive data formats to verify accurate detection and coverage."
          },
          {
            "id": 2,
            "title": "Develop Data Sanitization and Redaction Functionality",
            "description": "Implement a sanitization function that redacts detected sensitive data, replacing values with standardized placeholders such as '[REDACTED]' or '[SENSITIVE_DATA_HIDDEN]' while preserving output structure.",
            "dependencies": [
              "1.1"
            ],
            "details": "Ensure the sanitization logic works recursively for nested structures and supports multiple output formats (JSON, YAML, plain text). Maintain the original data structure for debugging and traceability.",
            "status": "cancelled",
            "testStrategy": "Unit test with diverse output samples to confirm that all sensitive fields are redacted and structure is preserved."
          },
          {
            "id": 3,
            "title": "Integrate Configurable Sanitization Levels",
            "description": "Add a configuration option to control the sanitization level (strict, moderate, disabled), defaulting to strict, and ensure this setting is respected throughout the dry-run output process.",
            "dependencies": [
              "1.2"
            ],
            "details": "Define the behavior for each sanitization level, document the configuration interface, and ensure the system defaults to strict mode for maximum security.",
            "status": "cancelled",
            "testStrategy": "Test all configuration levels with sample outputs to verify correct application of sanitization rules."
          },
          {
            "id": 4,
            "title": "Implement Output Format Compatibility and Whitelist Support",
            "description": "Ensure the sanitization system operates correctly across all supported output formats (JSON, YAML, plain text) and implement a whitelist mechanism for known safe fields to minimize false positives.",
            "dependencies": [
              "1.2"
            ],
            "details": "Test and adapt the sanitization logic for each output format. Define and maintain a whitelist of fields that should not be redacted, with clear documentation and update procedures.",
            "status": "cancelled",
            "testStrategy": "Integration tests with real-world dry-run outputs in all formats, verifying both redaction and whitelist effectiveness."
          },
          {
            "id": 5,
            "title": "Add User Warning and Documentation for Dry-Run Mode",
            "description": "Display a prominent warning message when dry-run mode is enabled, alerting users to the risk of sensitive data exposure, and provide clear documentation on sanitization behavior and configuration.",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "Implement warning banners/messages in stdout and logs. Update user documentation to explain sanitization, configuration options, and best practices for secure usage.",
            "status": "cancelled",
            "testStrategy": "Manual verification that warnings appear in all relevant contexts and that documentation is accurate and accessible."
          }
        ]
      },
      {
        "id": 2,
        "title": "Refactor Global Error Handler to Use Dependency Injection",
        "description": "Eliminate the global mutable state anti-pattern by refactoring the global errorHandler variable to use dependency injection or parameter passing for better code maintainability and thread safety.",
        "details": "This refactoring task involves eliminating the global errorHandler variable and implementing a cleaner architecture. The implementation should include: 1) Create an ErrorHandler interface or class that can be instantiated and passed as a dependency. 2) Modify all functions that currently rely on the global errorHandler to accept it as a parameter or through constructor injection. 3) Update the main application initialization to create an ErrorHandler instance and pass it to dependent components. 4) For testing scenarios, implement a factory pattern or configuration object that allows easy injection of mock error handlers. 5) Consider using a dependency injection container if the application grows in complexity. 6) Ensure that error handling behavior remains consistent across the application while removing the global state dependency. 7) Update any existing error handling logic to work with the new injection pattern. The solution should maintain backward compatibility where possible and provide clear migration paths for existing code.",
        "testStrategy": "Testing should verify the refactoring maintains functionality while improving architecture: 1) Unit tests should verify that all functions accepting the error handler parameter work correctly with both real and mock implementations. 2) Integration tests should confirm that error handling behavior is identical to the previous global implementation. 3) Concurrency tests should verify that multiple instances can operate safely without shared mutable state. 4) Mock injection tests should demonstrate that test scenarios can easily substitute different error handler implementations. 5) Regression tests should ensure that all existing error handling paths continue to work as expected. 6) Performance tests should confirm that the dependency injection approach doesn't introduce significant overhead compared to global variable access.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design ErrorHandler Interface or Class",
            "description": "Define an ErrorHandler interface or abstract class that encapsulates error handling logic, allowing for instantiation and dependency injection.",
            "dependencies": [],
            "details": "Specify the required methods and behaviors for error handling, ensuring extensibility for custom implementations and testability.",
            "status": "pending",
            "testStrategy": "Create unit tests to verify that different implementations of the ErrorHandler interface/class conform to the expected contract."
          },
          {
            "id": 2,
            "title": "Refactor Functions to Accept ErrorHandler Dependency",
            "description": "Modify all functions and components that currently use the global errorHandler variable to accept an ErrorHandler instance via parameter or constructor injection.",
            "dependencies": [
              "2.1"
            ],
            "details": "Update function signatures and constructors to require an ErrorHandler dependency, removing all references to the global variable.",
            "status": "pending",
            "testStrategy": "Ensure all affected functions are covered by unit tests that verify correct error handling with both real and mock ErrorHandler instances."
          },
          {
            "id": 3,
            "title": "Update Application Initialization for Dependency Injection",
            "description": "Refactor the main application startup to instantiate the ErrorHandler and inject it into all dependent components.",
            "dependencies": [
              "2.2"
            ],
            "details": "Modify the application's entry point to create an ErrorHandler instance and pass it to modules, services, or controllers that require error handling.",
            "status": "pending",
            "testStrategy": "Write integration tests to confirm that the ErrorHandler is correctly injected and used throughout the application lifecycle."
          },
          {
            "id": 4,
            "title": "Implement Test-Friendly ErrorHandler Injection",
            "description": "Introduce a factory pattern or configuration mechanism to allow easy injection of mock or test-specific ErrorHandler implementations.",
            "dependencies": [
              "2.1"
            ],
            "details": "Design a flexible approach for tests to provide custom ErrorHandler instances, supporting both unit and integration testing scenarios.",
            "status": "pending",
            "testStrategy": "Develop tests that inject mock ErrorHandler implementations and verify that error handling logic is invoked as expected in test environments."
          },
          {
            "id": 5,
            "title": "Migrate and Validate Error Handling Logic",
            "description": "Update all existing error handling logic to use the new injection pattern, ensuring consistent behavior and removing global state dependencies.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "Refactor legacy error handling code, validate that all error flows are preserved, and document migration steps for maintainers.",
            "status": "pending",
            "testStrategy": "Perform regression testing and review error handling across the application to ensure no loss of functionality or coverage."
          }
        ]
      },
      {
        "id": 3,
        "title": "Refactor Main Function Configuration Loading and Error Handling",
        "description": "Eliminate duplicate configuration loading in the main function and implement consistent error handling by loading config once and passing it through the application.",
        "details": "This refactoring task addresses the architectural issues in the main function's configuration handling. The implementation should include: 1) Remove the duplicate config loading by consolidating to a single config load operation at application startup. 2) Create a proper configuration passing mechanism - either through dependency injection, a context object, or explicit parameter passing to functions that need config access. 3) Implement consistent error handling for the configuration loading process with proper error propagation and user-friendly error messages. 4) Document and clarify the len(os.Args) != 1 condition - either remove it if unnecessary or add clear documentation explaining its purpose and expected behavior. 5) Ensure that configuration validation happens early and explicitly, with clear error messages for invalid configurations. 6) Consider implementing a configuration validation layer that checks for required fields, valid formats, and logical consistency before the application proceeds with its main operations. The refactored code should follow the single responsibility principle where configuration loading, validation, and usage are clearly separated.",
        "testStrategy": "Testing should verify both the refactoring correctness and improved error handling: 1) Unit tests should verify that configuration is loaded exactly once during application startup and that the same config instance is used throughout the application lifecycle. 2) Test various error scenarios including missing config files, malformed config content, and invalid configuration values to ensure consistent error handling and meaningful error messages. 3) Integration tests should verify that the len(os.Args) condition works as expected in different invocation scenarios (with and without arguments). 4) Performance tests should confirm that eliminating duplicate config loading improves startup time. 5) Regression tests should ensure that all existing functionality continues to work with the refactored configuration handling. 6) Mock tests should verify that functions receiving configuration as parameters work correctly with both real and test configuration objects.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Consolidate Configuration Loading at Startup",
            "description": "Remove all duplicate configuration loading logic from the main function and ensure configuration is loaded exactly once at application startup.",
            "dependencies": [],
            "details": "Identify all locations in the main function where configuration is loaded, eliminate redundant calls, and centralize the loading process to a single, well-defined point at startup. Ensure that the loaded configuration instance is reused throughout the application lifecycle.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify that configuration loading occurs only once and that no duplicate or redundant loading logic remains."
          },
          {
            "id": 2,
            "title": "Implement Configuration Passing Mechanism",
            "description": "Design and implement a mechanism to pass the loaded configuration throughout the application, using dependency injection, a context object, or explicit parameter passing.",
            "dependencies": [
              "3.1"
            ],
            "details": "Refactor functions and components that require configuration access to accept the configuration object as a parameter or through a context/dependency injection system. Update function signatures and initialization logic accordingly.",
            "status": "pending",
            "testStrategy": "Add unit and integration tests to confirm that all components receive the correct configuration instance and that configuration is not accessed globally or reloaded."
          },
          {
            "id": 3,
            "title": "Establish Consistent Error Handling for Configuration Loading",
            "description": "Implement robust error handling for the configuration loading process, ensuring errors are propagated and reported with user-friendly messages.",
            "dependencies": [
              "3.1"
            ],
            "details": "Refactor the configuration loading logic to handle all error cases consistently. Ensure that errors are not swallowed or ignored, and that meaningful, actionable error messages are provided to the user or calling code.",
            "status": "pending",
            "testStrategy": "Create tests that simulate various configuration loading failures (e.g., missing file, invalid format) and verify that errors are handled and reported as expected."
          },
          {
            "id": 4,
            "title": "Clarify or Remove len(os.Args) != 1 Condition",
            "description": "Review the use of the len(os.Args) != 1 condition in the main function, removing it if unnecessary or documenting its purpose and expected behavior clearly.",
            "dependencies": [
              "3.1"
            ],
            "details": "Analyze the logic and intent behind the len(os.Args) != 1 check. If it is not required, remove it. If it is necessary, add clear inline documentation explaining why it exists and what scenarios it covers.",
            "status": "pending",
            "testStrategy": "Test application startup with various command-line argument scenarios to ensure correct behavior and that documentation accurately reflects the logic."
          },
          {
            "id": 5,
            "title": "Implement Early and Explicit Configuration Validation",
            "description": "Introduce a configuration validation layer that checks for required fields, valid formats, and logical consistency before the application proceeds.",
            "dependencies": [
              "3.1"
            ],
            "details": "Develop validation logic that runs immediately after configuration loading. Ensure that invalid configurations are detected early, with clear error messages, and prevent the application from continuing with bad config.",
            "status": "pending",
            "testStrategy": "Write unit tests for the validation logic, covering cases of missing fields, invalid values, and logical inconsistencies. Verify that invalid configurations are rejected with appropriate errors."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Comprehensive Input Validation and Sanitization",
        "description": "Add comprehensive input validation for all user-provided parameters including title length limits, description content validation, parent ID existence checks, and organization/project name format validation before making API calls.",
        "details": "This task implements a robust input validation system to prevent invalid data from reaching the API layer. The implementation should include: 1) Create a ValidationService class with methods for validating different input types: validateTitle() for length limits (e.g., 1-255 characters), validateDescription() for content sanitization and length constraints, validateParentId() to verify parent work item existence, and validateOrgProject() for proper naming conventions. 2) Implement validation rules: Title validation should check for minimum/maximum length, forbidden characters, and HTML/script injection attempts. Description validation should sanitize HTML content, check for maximum length limits, and validate encoding. Parent ID validation should verify the ID exists in the target organization and is accessible. Organization/Project validation should check naming conventions, special character restrictions, and existence verification. 3) Create a centralized validation pipeline that processes all inputs before API calls, returning detailed error messages for validation failures. 4) Integrate validation with the existing error handling system to provide consistent error responses. 5) Add configuration options for validation rules (max lengths, allowed characters) to make the system flexible across different Azure DevOps instances. 6) Implement input sanitization to prevent injection attacks while preserving legitimate content formatting.",
        "testStrategy": "Testing should comprehensively verify all validation scenarios: 1) Unit tests for each validation method with boundary value testing (empty strings, maximum length strings, special characters, Unicode content). 2) Test validation failure scenarios with various invalid inputs (overly long titles, malformed parent IDs, invalid organization names, script injection attempts). 3) Integration tests that verify validation occurs before API calls and that valid inputs pass through correctly. 4) Security testing with common injection payloads (XSS, SQL injection patterns) to ensure proper sanitization. 5) Performance tests with large input datasets to ensure validation doesn't significantly impact application performance. 6) Test configuration flexibility by running validation with different rule sets. 7) Verify error message quality and consistency across different validation failures. 8) Test edge cases like Unicode characters, emoji, and different language inputs in titles and descriptions.",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement ValidationService Class",
            "description": "Create a ValidationService class with dedicated methods for validating each input type: validateTitle(), validateDescription(), validateParentId(), and validateOrgProject(). Ensure each method is responsible for enforcing the relevant validation logic for its input.",
            "dependencies": [],
            "details": "The ValidationService should encapsulate all input validation logic, making it reusable and testable. Each method must be clearly documented and support extension for future validation rules.",
            "status": "pending",
            "testStrategy": "Write unit tests for each validation method, covering valid and invalid input scenarios, including boundary values and edge cases."
          },
          {
            "id": 2,
            "title": "Implement Comprehensive Validation Rules and Sanitization",
            "description": "Define and enforce validation rules for all user-provided parameters, including title length and character restrictions, description content sanitization and length, parent ID existence, and organization/project name format and existence.",
            "dependencies": [
              "4.1"
            ],
            "details": "Validation rules must include checks for minimum/maximum lengths, forbidden characters, HTML/script injection attempts, and proper encoding. Description fields must be sanitized to prevent XSS and injection attacks while preserving legitimate formatting.",
            "status": "pending",
            "testStrategy": "Develop unit tests for each rule, including attempts to bypass validation with malicious input (e.g., scripts, SQL injection patterns, invalid encodings)."
          },
          {
            "id": 3,
            "title": "Develop Centralized Validation Pipeline",
            "description": "Create a centralized pipeline that processes all user inputs through the ValidationService before any API calls are made, ensuring consistent validation and error handling.",
            "dependencies": [
              "4.2"
            ],
            "details": "The pipeline should orchestrate the sequence of validations, aggregate errors, and halt processing on validation failure. It must return detailed, standardized error messages indicating which fields failed and why.",
            "status": "pending",
            "testStrategy": "Write integration tests simulating full input payloads, verifying that all invalid inputs are caught and that error messages are clear and actionable."
          },
          {
            "id": 4,
            "title": "Integrate Validation with Error Handling System",
            "description": "Connect the validation pipeline to the existing error handling system to ensure that validation errors are reported consistently and do not expose sensitive implementation details.",
            "dependencies": [
              "4.3"
            ],
            "details": "Validation errors should be mapped to standardized error responses, following API best practices for error reporting. Ensure that error messages are informative but do not leak internal logic or sensitive data.",
            "status": "pending",
            "testStrategy": "Test error propagation and formatting by triggering validation failures and verifying that error responses are consistent with the application's error handling conventions."
          },
          {
            "id": 5,
            "title": "Implement Configurable Validation Rule Options",
            "description": "Add configuration options for validation rules (such as maximum lengths and allowed characters) to support flexibility across different Azure DevOps instances and organizational requirements.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Expose validation parameters via configuration files or environment variables, allowing administrators to adjust rules without code changes. Ensure that the ValidationService reads and applies these settings dynamically.",
            "status": "pending",
            "testStrategy": "Write tests to verify that changes to configuration options are correctly reflected in validation behavior, including dynamic reloads if supported."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Proper Error Type Checking Using Azure DevOps SDK",
        "description": "Replace fragile string-matching error classification logic with proper error type checking using Azure DevOps SDK's actual error types to improve reliability and eliminate locale-dependent issues.",
        "details": "This task involves refactoring the error classification system to use proper type checking instead of brittle string matching. The implementation should include: 1) Remove all commented-out SDK-specific error type checks and replace string-based error detection with proper instanceof checks or error type properties from the Azure DevOps SDK. 2) Create an ErrorClassifier class that uses the SDK's native error types (e.g., VssServiceException, VssUnauthorizedException, VssResourceNotFoundException) to categorize errors appropriately. 3) Implement error mapping functions that translate SDK error types to application-specific error categories (authentication, authorization, network, validation, etc.). 4) Replace locale-dependent string matching patterns with error code checking or error type inspection that works consistently across different language settings. 5) Add proper error context extraction from SDK error objects to preserve meaningful error information while avoiding string parsing. 6) Ensure the error classification logic handles both synchronous and asynchronous error scenarios from Azure DevOps API calls. 7) Implement fallback error handling for unknown or new error types that may be introduced in future SDK versions.",
        "testStrategy": "Testing should comprehensively verify the new error classification system: 1) Unit tests should mock various Azure DevOps SDK error types and verify correct classification without relying on error message strings. Test scenarios should include authentication errors, authorization failures, network timeouts, resource not found errors, and validation failures. 2) Create test cases that simulate different locale settings to ensure error classification works consistently regardless of system language. 3) Integration tests should trigger actual API errors (using invalid credentials, non-existent resources, etc.) and verify that the new classification system correctly identifies error types. 4) Test error handling for edge cases including malformed responses, network interruptions, and SDK version compatibility. 5) Verify that error context and meaningful information is preserved during the classification process. 6) Performance tests should ensure the new type-based classification is more efficient than string matching. 7) Regression tests should confirm that all existing error handling behavior is maintained while improving reliability.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove String-Based Error Classification Logic",
            "description": "Eliminate all fragile string-matching logic and commented-out SDK-specific error type checks from the error classification system.",
            "dependencies": [],
            "details": "Refactor the codebase to remove any error classification that relies on matching error message strings or locale-dependent patterns. Ensure that only error type or property-based checks remain.",
            "status": "pending",
            "testStrategy": "Verify via code review and static analysis that no string-based or locale-dependent error checks remain. Run regression tests to confirm no loss of error detection coverage."
          },
          {
            "id": 2,
            "title": "Implement ErrorClassifier Using Azure DevOps SDK Error Types",
            "description": "Create an ErrorClassifier class that uses Azure DevOps SDK's native error types (e.g., VssServiceException, VssUnauthorizedException, VssResourceNotFoundException) for error categorization.",
            "dependencies": [
              "5.1"
            ],
            "details": "Design and implement the ErrorClassifier class to use instanceof checks or error type properties from the SDK for robust error type detection. Ensure the class is extensible for future SDK error types.",
            "status": "pending",
            "testStrategy": "Unit test the ErrorClassifier with mocked SDK error objects to verify correct type-based classification for all supported error types."
          },
          {
            "id": 3,
            "title": "Develop Error Mapping Functions to Application Error Categories",
            "description": "Implement functions that map SDK error types to application-specific error categories such as authentication, authorization, network, and validation errors.",
            "dependencies": [
              "5.2"
            ],
            "details": "Define a mapping layer that translates recognized SDK error types into standardized application error categories. Ensure the mapping is comprehensive and maintainable.",
            "status": "pending",
            "testStrategy": "Test mapping functions with a variety of SDK error instances to confirm correct categorization. Include edge cases and unknown error types."
          },
          {
            "id": 4,
            "title": "Extract and Preserve Error Context from SDK Error Objects",
            "description": "Implement logic to extract relevant context (e.g., error codes, correlation IDs, timestamps) from SDK error objects, avoiding string parsing.",
            "dependencies": [
              "5.2"
            ],
            "details": "Leverage structured properties on SDK error objects to capture and log meaningful error context. Ensure no reliance on parsing error message strings.",
            "status": "pending",
            "testStrategy": "Unit test context extraction with diverse SDK error objects, verifying that all relevant fields are captured and no string parsing is used."
          },
          {
            "id": 5,
            "title": "Handle Asynchronous and Unknown Error Scenarios",
            "description": "Ensure error classification logic supports both synchronous and asynchronous Azure DevOps API errors, and implements fallback handling for unknown or new error types.",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Update error handling to work seamlessly with both sync and async API calls. Add fallback logic to gracefully handle unrecognized or future SDK error types, ensuring robust error reporting.",
            "status": "pending",
            "testStrategy": "Test with both synchronous and asynchronous error scenarios, including simulated unknown error types, to confirm correct fallback and error handling behavior."
          }
        ]
      },
      {
        "id": 6,
        "title": "Fix Race Condition in Error Handler Test Override",
        "description": "Resolve race conditions in test code that overrides the global errorHandler variable without proper synchronization by implementing thread-safe testing mechanisms.",
        "details": "This task addresses the race condition vulnerability in test code that unsafely overrides the global errorHandler variable. The implementation should include: 1) Analyze all test files that modify the global errorHandler and identify potential race conditions when tests run in parallel. 2) Implement one of two solutions: either add t.Parallel() restrictions to prevent concurrent execution of tests that modify global state, or implement proper synchronization mechanisms using mutexes or channels. 3) If choosing synchronization, create a thread-safe wrapper around errorHandler access that uses sync.RWMutex to coordinate read/write operations. 4) For the t.Parallel() approach, mark conflicting tests with appropriate parallel execution constraints and document why certain tests cannot run concurrently. 5) Consider refactoring tests to use dependency injection instead of global state modification where feasible. 6) Add proper cleanup mechanisms in test teardown to restore original errorHandler state. 7) Implement test isolation by ensuring each test gets a clean errorHandler state regardless of execution order.",
        "testStrategy": "Testing should verify race condition elimination and maintain test reliability: 1) Run the test suite multiple times with parallel execution enabled to verify no race conditions occur during concurrent test execution. 2) Create specific race condition tests that attempt to trigger the original issue by running multiple goroutines that simultaneously access and modify the errorHandler. 3) Use Go's race detector (go test -race) to verify no data races are detected in the test suite. 4) Test both sequential and parallel test execution modes to ensure tests pass in both scenarios. 5) Verify that test isolation works correctly by running tests in random order and ensuring consistent results. 6) Mock testing scenarios where errorHandler modifications occur during concurrent operations to validate synchronization mechanisms. 7) Performance testing to ensure synchronization overhead doesn't significantly impact test execution time.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Test Files for Global errorHandler Modification",
            "description": "Identify all test files and cases that modify the global errorHandler variable and document where and how these modifications occur.",
            "dependencies": [],
            "details": "Perform a comprehensive codebase search to locate every instance where the global errorHandler is overridden or accessed in test code. Record the affected files, test functions, and the nature of the modifications.",
            "status": "pending",
            "testStrategy": "No direct tests; verification is by completeness of the audit and documentation."
          },
          {
            "id": 2,
            "title": "Detect and Document Potential Race Conditions",
            "description": "Analyze the identified test cases to determine where race conditions may occur, especially when tests are run in parallel.",
            "dependencies": [
              "6.1"
            ],
            "details": "Review the audit results to find tests that could run concurrently and access or modify errorHandler unsafely. Use Go's race detector (`go test -race`) to confirm the presence of race conditions in these scenarios.",
            "status": "pending",
            "testStrategy": "Run the test suite with the race detector enabled and document any detected race conditions."
          },
          {
            "id": 3,
            "title": "Implement Thread-Safe Access to errorHandler",
            "description": "Introduce synchronization mechanisms (e.g., sync.RWMutex) to ensure thread-safe access and modification of the global errorHandler variable in tests.",
            "dependencies": [
              "6.2"
            ],
            "details": "Wrap all accesses and modifications to errorHandler in a thread-safe interface using sync.RWMutex. Refactor test code to use this wrapper, ensuring no unsynchronized access remains.",
            "status": "pending",
            "testStrategy": "Re-run the test suite with the race detector to verify that no race conditions are reported after synchronization is implemented."
          },
          {
            "id": 4,
            "title": "Enforce Test Isolation and Cleanup",
            "description": "Ensure each test that modifies errorHandler restores its original state after execution, regardless of test order or parallelism.",
            "dependencies": [
              "6.3"
            ],
            "details": "Implement setup and teardown logic in each relevant test to save the original errorHandler before modification and restore it after the test completes, using defer or test cleanup hooks.",
            "status": "pending",
            "testStrategy": "Add tests that intentionally run conflicting tests in parallel to verify that errorHandler state is correctly isolated and restored."
          },
          {
            "id": 5,
            "title": "Refactor Tests to Minimize Global State Usage",
            "description": "Where feasible, refactor tests to use dependency injection or local errorHandler instances instead of modifying global state.",
            "dependencies": [
              "6.4"
            ],
            "details": "Update test and production code to accept errorHandler as a parameter or via dependency injection, reducing reliance on the global variable and improving testability and thread safety.",
            "status": "pending",
            "testStrategy": "Verify that refactored tests pass and that errorHandler is no longer shared globally, using code review and automated tests."
          }
        ]
      },
      {
        "id": 7,
        "title": "Make Azure DevOps Base URL Configurable",
        "description": "Replace hardcoded 'https://dev.azure.com/' URL patterns throughout the codebase with configurable base URL support through environment variables or configuration files to enable support for different Azure DevOps instances.",
        "details": "This task involves making the Azure DevOps base URL configurable to support different instances (cloud, on-premises, or custom domains). The implementation should include: 1) Identify all hardcoded 'https://dev.azure.com/' occurrences in the codebase and catalog their usage patterns. 2) Add a new configuration parameter 'AZURE_DEVOPS_BASE_URL' to the configuration system with 'https://dev.azure.com/' as the default value. 3) Create a URLBuilder utility class or service that constructs Azure DevOps URLs using the configurable base URL, handling proper path concatenation and URL encoding. 4) Replace all hardcoded URL construction with calls to the URLBuilder service, ensuring consistent URL formatting across the application. 5) Update environment variable documentation and configuration examples to include the new AZURE_DEVOPS_BASE_URL parameter. 6) Implement validation for the base URL format to ensure it's a valid URL and follows expected patterns (e.g., must be HTTPS, proper domain format). 7) Consider backward compatibility by maintaining the default behavior when the configuration is not provided. The URLBuilder should handle various Azure DevOps URL patterns including organization URLs, project URLs, and API endpoints while maintaining proper URL structure and encoding.",
        "testStrategy": "Testing should verify configurable URL functionality across different scenarios: 1) Unit tests for the URLBuilder utility with various base URL configurations including default Azure DevOps cloud URL, on-premises server URLs, and custom domain scenarios. Test proper URL concatenation, encoding, and format validation. 2) Integration tests that verify the application works correctly with different base URL configurations by mocking Azure DevOps responses from alternative endpoints. 3) Configuration validation tests to ensure invalid URLs are rejected with appropriate error messages (malformed URLs, non-HTTPS URLs, empty values). 4) Environment variable tests to verify the configuration loading works correctly when AZURE_DEVOPS_BASE_URL is set, unset, or contains invalid values. 5) Regression tests to ensure all existing functionality continues to work with the default configuration. 6) End-to-end tests with a test Azure DevOps instance using a non-standard base URL to verify complete functionality. Test both successful operations and error scenarios to ensure proper URL construction in all code paths.",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Catalog All Hardcoded Azure DevOps Base URL Usages",
            "description": "Identify and document every occurrence of the hardcoded 'https://dev.azure.com/' base URL throughout the codebase, including all usage patterns (API endpoints, organization/project URLs, etc.).",
            "dependencies": [],
            "details": "Perform a comprehensive search for all instances of the hardcoded Azure DevOps base URL. Record the context and usage pattern for each occurrence to inform subsequent refactoring.",
            "status": "pending",
            "testStrategy": "Peer review the catalog to ensure completeness and accuracy; verify that all relevant code paths are covered."
          },
          {
            "id": 2,
            "title": "Introduce Configurable Base URL Parameter",
            "description": "Add a new configuration parameter 'AZURE_DEVOPS_BASE_URL' to the application's configuration system, defaulting to 'https://dev.azure.com/'.",
            "dependencies": [
              "7.1"
            ],
            "details": "Update the configuration schema and environment variable documentation to support the new parameter. Ensure backward compatibility by using the default value if the parameter is not set.",
            "status": "pending",
            "testStrategy": "Unit test configuration loading with and without the environment variable set; verify default and custom values are handled correctly."
          },
          {
            "id": 3,
            "title": "Implement URLBuilder Utility for Azure DevOps URLs",
            "description": "Develop a URLBuilder utility class or service that constructs all Azure DevOps URLs using the configurable base URL, ensuring correct path concatenation and URL encoding.",
            "dependencies": [
              "7.2"
            ],
            "details": "The utility should support organization URLs, project URLs, and API endpoints, handling spaces and special characters as required by Azure DevOps URL conventions.",
            "status": "pending",
            "testStrategy": "Unit test the URLBuilder with various base URLs and path inputs, including edge cases (spaces, custom domains, on-premises URLs)."
          },
          {
            "id": 4,
            "title": "Refactor Codebase to Use URLBuilder for All Azure DevOps URL Construction",
            "description": "Replace all direct and hardcoded Azure DevOps URL constructions in the codebase with calls to the new URLBuilder utility, ensuring consistent and correct URL formatting.",
            "dependencies": [
              "7.3"
            ],
            "details": "Update all relevant code paths to use the URLBuilder, removing any remaining hardcoded base URLs. Ensure all usages are covered, including REST API calls and UI links.",
            "status": "pending",
            "testStrategy": "Integration test all features that interact with Azure DevOps to confirm correct URL generation and system behavior across different base URL configurations."
          },
          {
            "id": 5,
            "title": "Update Documentation and Validate Base URL Format",
            "description": "Revise environment variable documentation and configuration examples to include 'AZURE_DEVOPS_BASE_URL', and implement validation logic to ensure the base URL is a valid HTTPS URL and matches expected patterns.",
            "dependencies": [
              "7.4"
            ],
            "details": "Document the new configuration parameter in all relevant guides. Add validation checks to reject invalid or insecure base URLs (e.g., non-HTTPS, malformed domains).",
            "status": "pending",
            "testStrategy": "Test documentation accuracy and validation logic by providing various valid and invalid base URL values; verify that errors are handled and documented as expected."
          }
        ]
      },
      {
        "id": 8,
        "title": "Add Comprehensive Error Scenario Test Coverage",
        "description": "Implement comprehensive test coverage for critical error scenarios including network timeouts, malformed responses, rate limiting, and authentication failures to ensure error classification works correctly across all failure modes.",
        "details": "This task involves creating a comprehensive test suite for error scenarios that are currently not covered. The implementation should include: 1) Network timeout testing - Create mock scenarios that simulate various timeout conditions (connection timeout, read timeout, request timeout) and verify that the error classification system properly identifies and categorizes these failures. Use test utilities to simulate slow network responses and connection drops. 2) Malformed response testing - Generate test cases with invalid JSON responses, incomplete data structures, missing required fields, and corrupted response bodies to ensure the application handles parsing errors gracefully and classifies them appropriately. 3) Rate limiting scenario testing - Mock HTTP 429 responses with various rate limiting headers (Retry-After, X-RateLimit-*) and verify that the error classification system correctly identifies rate limiting errors and extracts retry information. Test both temporary and quota-exceeded rate limiting scenarios. 4) Authentication failure testing - Create comprehensive tests for different authentication error types including expired tokens, invalid credentials, insufficient permissions, and token refresh failures. Mock various HTTP status codes (401, 403) with different error response formats to ensure proper classification. 5) Integration with the ErrorClassifier - Ensure all new error scenario tests work with the proper error type checking system and validate that error classification is consistent and reliable across all failure modes. 6) Error recovery testing - Verify that the application can recover gracefully from these error scenarios and that error messages are informative for debugging purposes.",
        "testStrategy": "Testing should comprehensively validate error scenario coverage and classification accuracy: 1) Create unit tests for each error scenario type using mock HTTP responses and network simulation tools. Verify that each error type is correctly identified and classified by the error handling system. 2) Integration tests should simulate real-world error conditions using test doubles and verify end-to-end error handling behavior. Test scenarios should include network instability, API service degradation, and authentication token expiration. 3) Regression testing should ensure that existing functionality continues to work correctly when new error scenarios are encountered. Run the full test suite with error injection to verify system stability. 4) Coverage analysis should confirm that all critical error paths are tested and that error classification logic has complete test coverage. Use code coverage tools to identify any untested error handling branches. 5) Performance testing should verify that error handling doesn't introduce significant latency or resource consumption during failure scenarios. 6) Manual testing should include triggering actual error conditions in a test environment to validate that mocked scenarios accurately represent real-world failures.",
        "status": "pending",
        "dependencies": [
          5
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Network Timeout Error Scenario Tests",
            "description": "Create and execute tests that simulate various network timeout conditions, including connection timeout, read timeout, and request timeout. Use network simulation tools or mocks to induce slow responses and dropped connections. Verify that the error classification system accurately identifies and categorizes each timeout failure.",
            "dependencies": [],
            "details": "Design test cases for each type of network timeout. Integrate these tests with the error classification system to ensure correct identification and categorization. Document the scenarios and expected outcomes.",
            "status": "pending",
            "testStrategy": "Use unit and integration tests with network simulation utilities to trigger timeouts. Assert that the error classifier assigns the correct error type for each scenario."
          },
          {
            "id": 2,
            "title": "Implement Malformed Response Error Scenario Tests",
            "description": "Develop tests that provide invalid, incomplete, or corrupted response bodies, such as malformed JSON, missing required fields, and truncated data. Ensure the application handles parsing errors gracefully and that the error classification system categorizes them appropriately.",
            "dependencies": [],
            "details": "Generate a variety of malformed responses and inject them into the system under test. Validate that parsing errors are detected and classified as intended.",
            "status": "pending",
            "testStrategy": "Create unit tests with mocked HTTP responses containing malformed data. Verify that the error classifier produces the expected error types and that error messages are informative."
          },
          {
            "id": 3,
            "title": "Implement Rate Limiting Error Scenario Tests",
            "description": "Simulate HTTP 429 responses with different rate limiting headers (e.g., Retry-After, X-RateLimit-*) and test both temporary and quota-exceeded scenarios. Confirm that the error classification system identifies rate limiting errors and extracts retry information correctly.",
            "dependencies": [],
            "details": "Mock HTTP responses for various rate limiting cases. Test the extraction and handling of retry headers and ensure proper error categorization.",
            "status": "pending",
            "testStrategy": "Write unit tests for each rate limiting scenario. Assert that the error classifier recognizes rate limiting and that retry logic is triggered as appropriate."
          },
          {
            "id": 4,
            "title": "Implement Authentication Failure Error Scenario Tests",
            "description": "Create comprehensive tests for authentication failures, including expired tokens, invalid credentials, insufficient permissions, and token refresh failures. Mock HTTP 401 and 403 responses with different error formats to verify correct error classification.",
            "dependencies": [],
            "details": "Design test cases for each authentication failure type. Use mocks to simulate various authentication error responses and validate error classification.",
            "status": "pending",
            "testStrategy": "Develop unit tests for each authentication scenario. Check that the error classifier assigns the correct error type and that error messages aid debugging."
          },
          {
            "id": 5,
            "title": "Validate ErrorClassifier Integration and Error Recovery",
            "description": "Ensure all new error scenario tests are integrated with the ErrorClassifier and that error classification is consistent and reliable across all failure modes. Verify that the application recovers gracefully from errors and provides informative error messages.",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Integrate all scenario tests with the ErrorClassifier. Test error recovery mechanisms and validate that error messages are clear and actionable.",
            "status": "pending",
            "testStrategy": "Run the full test suite and confirm that all error scenarios are classified correctly. Test recovery logic and review error outputs for clarity and usefulness."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Configurable Timeout Configuration for Azure DevOps Client",
        "description": "Replace the use of context.Background() with configurable timeout contexts for Azure DevOps API operations to prevent indefinite hangs during network issues and improve application reliability.",
        "details": "This task involves implementing a comprehensive timeout configuration system for the Azure DevOps client to prevent network-related hangs. The implementation should include: 1) Add timeout configuration parameters to the application config system including 'AZURE_DEVOPS_REQUEST_TIMEOUT' (default: 30s), 'AZURE_DEVOPS_CONNECTION_TIMEOUT' (default: 10s), and 'AZURE_DEVOPS_DIAL_TIMEOUT' (default: 5s). 2) Create a ContextManager utility that generates appropriate context.WithTimeout() contexts based on operation type (read operations vs write operations may have different timeout requirements). 3) Replace all instances of context.Background() in Azure DevOps client operations with properly configured timeout contexts. 4) Implement timeout hierarchy where individual operation timeouts can override global defaults. 5) Add proper timeout error handling that distinguishes between timeout errors and other network failures for better error classification. 6) Create HTTP client configuration with proper timeout settings for connection, TLS handshake, and response header timeouts. 7) Implement retry logic with exponential backoff for timeout scenarios where appropriate. 8) Add logging for timeout events to help with debugging and monitoring. The solution should be backward compatible and gracefully handle timeout configuration errors by falling back to reasonable defaults.",
        "testStrategy": "Testing should comprehensively verify timeout functionality across different scenarios: 1) Unit tests for the ContextManager utility with various timeout configurations, verifying that contexts are created with correct timeout values and that timeout hierarchy works properly. 2) Integration tests using mock HTTP servers that simulate slow responses, connection delays, and network partitions to verify that timeouts are properly enforced and don't cause indefinite hangs. 3) Test timeout error handling by creating scenarios where operations exceed configured timeouts and verify that proper timeout errors are returned and classified correctly by the error handling system. 4) Performance tests to ensure timeout configuration doesn't introduce significant overhead to normal operations. 5) Configuration validation tests to verify that invalid timeout values are handled gracefully with appropriate fallbacks. 6) Test concurrent operations with different timeout requirements to ensure no interference between operations. 7) End-to-end tests with real Azure DevOps API calls using various timeout configurations to verify production behavior. 8) Test timeout behavior during network instability scenarios using network simulation tools.",
        "status": "pending",
        "dependencies": [
          3,
          5
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Timeout Configuration Parameters to Application Config",
            "description": "Introduce new configuration parameters for request, connection, and dial timeouts in the application's configuration system, ensuring defaults are set (e.g., AZURE_DEVOPS_REQUEST_TIMEOUT: 30s, AZURE_DEVOPS_CONNECTION_TIMEOUT: 10s, AZURE_DEVOPS_DIAL_TIMEOUT: 5s).",
            "dependencies": [],
            "details": "Update the configuration schema and documentation to include the new timeout parameters. Ensure backward compatibility by providing sensible defaults if configuration values are missing or invalid.",
            "status": "pending",
            "testStrategy": "Unit tests should verify that configuration values are correctly loaded, defaults are applied when values are missing, and invalid values are handled gracefully."
          },
          {
            "id": 2,
            "title": "Implement ContextManager Utility for Timeout Contexts",
            "description": "Develop a ContextManager utility that generates context.WithTimeout() contexts based on operation type, supporting different timeout values for read and write operations.",
            "dependencies": [
              "9.1"
            ],
            "details": "The utility should accept operation type and configuration, returning a context with the appropriate timeout. It must support both global defaults and per-operation overrides.",
            "status": "pending",
            "testStrategy": "Unit tests should cover context creation for various operation types and timeout configurations, ensuring correct timeout assignment and override behavior."
          },
          {
            "id": 3,
            "title": "Replace context.Background() with Configured Timeout Contexts",
            "description": "Refactor all Azure DevOps client operations to use the ContextManager utility instead of context.Background(), ensuring every API call is wrapped with a properly configured timeout context.",
            "dependencies": [
              "9.2"
            ],
            "details": "Identify all usages of context.Background() in the Azure DevOps client codebase and systematically replace them with contexts generated by the ContextManager.",
            "status": "pending",
            "testStrategy": "Integration tests should verify that all API operations respect the configured timeouts and that no operation uses an unbounded context."
          },
          {
            "id": 4,
            "title": "Implement Timeout Hierarchy and Error Handling",
            "description": "Establish a timeout hierarchy allowing per-operation overrides of global defaults, and implement error handling that distinguishes timeout errors from other network failures.",
            "dependencies": [
              "9.3"
            ],
            "details": "Design the system so that operation-specific timeouts take precedence over global settings. Enhance error handling logic to classify and log timeout errors distinctly from other errors.",
            "status": "pending",
            "testStrategy": "Unit and integration tests should verify correct timeout precedence and that timeout errors are properly classified and logged."
          },
          {
            "id": 5,
            "title": "Configure HTTP Client and Add Retry, Logging, and Fallbacks",
            "description": "Configure the HTTP client with connection, TLS handshake, and response header timeouts. Implement retry logic with exponential backoff for timeout scenarios and add logging for all timeout events.",
            "dependencies": [
              "9.4"
            ],
            "details": "Ensure the HTTP client enforces all relevant timeouts. Implement retry mechanisms for transient timeout errors, and add structured logging for all timeout and retry events. Ensure the system falls back to defaults if configuration errors occur.",
            "status": "pending",
            "testStrategy": "Integration tests should simulate network delays and failures to verify HTTP client timeouts, retry logic, and logging. Tests should also confirm fallback behavior when configuration is invalid."
          }
        ]
      },
      {
        "id": 10,
        "title": "Refactor Error Handler Function Signature to Explicitly Handle Non-Returning Behavior",
        "description": "Refactor the errorHandler function to have an explicit signature that indicates it does not return, eliminating unreachable code patterns and improving code clarity.",
        "details": "This task involves refactoring the errorHandler function to address the issue where os.Exit(1) is called but some code paths expect the function might return. The implementation should include: 1) Analyze all current usages of the errorHandler function throughout the codebase to identify patterns where code expects it to return versus where it calls os.Exit(1). 2) Implement one of two solutions: Option A - Make the function signature explicit about non-returning behavior by changing the return type to indicate it never returns (e.g., using a 'never' type equivalent or panic/fatal pattern), or Option B - Modify the function to return an error instead of calling os.Exit(1) directly, allowing callers to decide whether to exit or handle the error. 3) If choosing Option A, update the function signature to func errorHandler(...) -> ! or equivalent non-returning indicator, and ensure all call sites understand this behavior. If choosing Option B, change the signature to func errorHandler(...) error and update all call sites to handle the returned error appropriately. 4) Remove any unreachable code that appears after errorHandler calls, replacing it with appropriate error handling or early returns. 5) Update any test code that mocks or overrides the errorHandler to match the new signature and behavior pattern. 6) Ensure consistency across the codebase so that error handling patterns are uniform and predictable.",
        "testStrategy": "Testing should verify the refactored error handler behavior and eliminate unreachable code issues: 1) Create unit tests that verify the new errorHandler signature behaves as expected - if it's non-returning, test that it properly terminates execution; if it returns errors, test that appropriate errors are returned for different failure scenarios. 2) Run static analysis tools or linters to verify that no unreachable code remains after errorHandler calls throughout the codebase. 3) Create integration tests that exercise error paths to ensure the new error handling pattern works correctly in realistic failure scenarios. 4) Test the interaction between the refactored errorHandler and existing error classification systems to ensure compatibility. 5) If the function now returns errors instead of exiting, create tests that verify callers properly handle the returned errors and make appropriate decisions about program termination. 6) Verify that any test mocks or overrides of the errorHandler function work correctly with the new signature and don't introduce race conditions or unexpected behavior.",
        "status": "pending",
        "dependencies": [
          6
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit All Usages of errorHandler Function",
            "description": "Identify and document every location in the codebase where the errorHandler function is called, noting whether the caller expects the function to return or expects it to terminate execution (e.g., via os.Exit or panic).",
            "dependencies": [],
            "details": "Perform a comprehensive search for all errorHandler invocations. Categorize each usage based on whether subsequent code assumes errorHandler returns or not. Highlight any patterns of unreachable code or inconsistent expectations.",
            "status": "pending",
            "testStrategy": "No direct tests; verification is by completeness of the audit and accuracy of the categorization."
          },
          {
            "id": 2,
            "title": "Select and Design the New errorHandler Signature",
            "description": "Choose between making errorHandler explicitly non-returning (using a 'never' type or panic/exit) or returning an error, and design the new function signature accordingly.",
            "dependencies": [
              "10.1"
            ],
            "details": "Based on the audit, decide which approach (non-returning or error-returning) best fits the codebase. Draft the new function signature and document the intended behavior for all callers.",
            "status": "pending",
            "testStrategy": "Peer review of the proposed signature and rationale to ensure it addresses all identified usage patterns."
          },
          {
            "id": 3,
            "title": "Refactor errorHandler Implementation and Update All Call Sites",
            "description": "Implement the new errorHandler function signature and update every call site to match the new contract, ensuring that all code paths are consistent with the new behavior.",
            "dependencies": [
              "10.2"
            ],
            "details": "Change the function definition and refactor all usages. For non-returning, ensure no code follows errorHandler calls. For error-returning, ensure all callers handle the error appropriately.",
            "status": "pending",
            "testStrategy": "Run static analysis and compilation checks to confirm all call sites are updated and no unreachable code remains."
          },
          {
            "id": 4,
            "title": "Remove Unreachable Code and Enforce Consistent Error Handling",
            "description": "Eliminate any code that is unreachable after errorHandler calls and replace it with appropriate error handling or early returns, ensuring uniformity across the codebase.",
            "dependencies": [
              "10.3"
            ],
            "details": "Systematically review all locations where errorHandler is used to remove dead code and enforce the new error handling pattern. Refactor as needed for clarity and maintainability.",
            "status": "pending",
            "testStrategy": "Code review and static analysis to verify that no unreachable code remains and error handling is consistent."
          },
          {
            "id": 5,
            "title": "Update and Expand Test Coverage for errorHandler Changes",
            "description": "Revise all test code that mocks or overrides errorHandler to match the new signature and behavior, and add or update tests to verify correct error handling and termination behavior.",
            "dependencies": [
              "10.4"
            ],
            "details": "Modify existing unit and integration tests to use the new errorHandler signature. Add tests to cover both normal and edge cases, including termination and error propagation scenarios.",
            "status": "pending",
            "testStrategy": "Run the full test suite to ensure all tests pass and add new tests to cover any previously untested scenarios introduced by the refactor."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-30T11:49:01.064Z",
      "updated": "2025-07-30T12:08:37.026Z",
      "description": "Sprint tag for issues found in code review on July 30, 2025"
    }
  }
}